<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-circle.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sixwudou.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="选择有时候比努力更重要">
<meta property="og:type" content="website">
<meta property="og:title" content="毋  豆 Blog">
<meta property="og:url" content="https://sixwudou.github.io/index.html">
<meta property="og:site_name" content="毋  豆 Blog">
<meta property="og:description" content="选择有时候比努力更重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="毋  豆">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://sixwudou.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>毋  豆 Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
	<a target="_blank" rel="noopener" href="https://github.com/sixwudou" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">毋  豆 Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sixwudou.github.io/2022/02/13/1020/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.gif">
      <meta itemprop="name" content="毋  豆">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="毋  豆 Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/13/1020/" class="post-title-link" itemprop="url">1020</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-13 00:03:25 / 修改时间：00:04:07" itemprop="dateCreated datePublished" datetime="2022-02-13T00:03:25+08:00">2022-02-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1020-飞地的数量"><a href="#1020-飞地的数量" class="headerlink" title="1020. 飞地的数量"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-enclaves/">1020. 飞地的数量</a></h4><p>难度中等131</p>
<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> ，其中 <code>0</code> 表示一个海洋单元格、<code>1</code> 表示一个陆地单元格。</p>
<p>一次 <strong>移动</strong> 是指从一个陆地单元格走到另一个相邻（<strong>上、下、左、右</strong>）的陆地单元格或跨过 <code>grid</code> 的边界。</p>
<p>返回网格中 <strong>无法</strong> 在任意次数的移动中离开网格边界的陆地单元格的数量。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/enclaves1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]</span><br><span class="line">输出：3</span><br><span class="line">解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/enclaves2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]</span><br><span class="line">输出：0</span><br><span class="line">解释：所有 1 都在边界上或可以到达边界。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 500</code></li>
<li><code>grid[i][j]</code> 的值为 <code>0</code> 或 <code>1</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] visited;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numEnclaves</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dfs(grid, i, <span class="number">0</span>);</span><br><span class="line">            dfs(grid, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            dfs(grid, <span class="number">0</span>, j);</span><br><span class="line">            dfs(grid, m - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> enclaves = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                    enclaves++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enclaves;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= m || col &lt; <span class="number">0</span> || col &gt;= n || grid[row][col] == <span class="number">0</span> || visited[row][col]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[row][col] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">            dfs(grid, row + dir[<span class="number">0</span>], col + dir[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sixwudou.github.io/2022/02/12/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.gif">
      <meta itemprop="name" content="毋  豆">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="毋  豆 Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/12/Spring/" class="post-title-link" itemprop="url">Spring</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-12 18:02:43" itemprop="dateCreated datePublished" datetime="2022-02-12T18:02:43+08:00">2022-02-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sixwudou.github.io/2022/02/12/%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.gif">
      <meta itemprop="name" content="毋  豆">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="毋  豆 Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/12/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-12 18:02:16 / 修改时间：20:16:18" itemprop="dateCreated datePublished" datetime="2022-02-12T18:02:16+08:00">2022-02-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h1><h2 id="连接查询-必会"><a href="#连接查询-必会" class="headerlink" title="连接查询(必会)"></a>连接查询(必会)</h2><p>1.****左连接****（左外连接）以左表为基准进行查询,左表数据会全部显示出来, 右表 如果和左表匹配 的数据则显示相应字段的数据,如果不匹配,则显示为NULL;</p>
<p>2.****右连接****（右外连接）以右表为基准进行查询,右表数据会全部显示出来, 右表 如果和左表匹配的数据则显示相应字段的数据,如果不匹配,则显示为NULL;</p>
<p>3.****全连接****就是先以左表进行左外连接，然后以右表进行右外连接。</p>
<p>****内连接****：</p>
<p>显示表之间有连接匹配的所有行。</p>
<h2 id="聚合函数-必会"><a href="#聚合函数-必会" class="headerlink" title="聚合函数(必会)"></a>聚合函数(必会)</h2><p>聚合函数是对一组值进行计算并返回单一的值的函数，它经常与 select 语句中的 group by 子句一同使用。</p>
<p><strong>1)</strong> ****avg()****：返回的是指定组中的平均值，空值被忽略。</p>
<p><strong>2)</strong> ****count()****：返回的是指定组中的项目个数。</p>
<p><strong>3)</strong> ****max()****：返回指定数据中的最大值。</p>
<p><strong>4)</strong> ****min()****：返回指定数据中的最小值。</p>
<p><strong>5)</strong> ****sum()****：返回指定数据的和，只能用于数字列，空值忽略。</p>
<p><strong>6)</strong> ****group by()****：对数据进行分组，对执行完 group by 之后的组进行聚合函数的运算，计算每一组的值。最后用 having 去掉不符合条件的组，having 子句中的每一个元素必须出现在 select 列表中（只针对于 mysql）。</p>
<h2 id="SQL注入-必会"><a href="#SQL注入-必会" class="headerlink" title="SQL注入(必会)"></a>SQL注入(必会)</h2><p>举例：</p>
<p>select admin from user where username=’admin’ or ‘a’=’a’ and passwd=’’or ‘a’=’a’</p>
<p>防止 SQL 注入，使用预编译语句是预防 SQL 注入的最佳方式，如</p>
<p>select admin from user where username=？And password=?</p>
<p>使用预编译的 SQL 语句语义不会发生改变，在 SQL 语句中，变量用问号？ 表示。像上面例子中，username 变量传递的’admin’ or ‘a’=’a’ 参数，也只会当 作 username 字符串来解释查询，从根本上杜绝了 SQL 注入攻击的发生。</p>
<p>注意：使用 mybaits 时 mapper 中#方式能够很大程度防止 SQL 注入，$方式 无法防止 SQL 注入.</p>
<h2 id="Select-语句完整的执行顺序-必会"><a href="#Select-语句完整的执行顺序-必会" class="headerlink" title="Select*语句完整的执行顺序(必会)"></a>Select*语句完整的执行顺序(必会)</h2><p>查询中用到的关键词主要包含六个，并且他们的顺序依次为<em><strong>*select–from–where–group by–having–order by*</strong></em></p>
<p>其中 <em><strong>*select*</strong></em> 和 <em><strong>*from*</strong></em> 是必须的，其他关键词是可选的， 这六个关键词的执行顺序如下：</p>
<p><em><strong>*from*</strong></em>: 需要从哪个数据表检索数据</p>
<p><em><strong>*where*</strong></em>: 过滤表中数据的条件</p>
<p><em><strong>*group by*</strong></em>: 如何将上面过滤出的数据分组算结果</p>
<p><em><strong>*order by*</strong></em> : 按照什么样的顺序来查看返回的数据</p>
<h2 id="存储引擎（高薪常问）"><a href="#存储引擎（高薪常问）" class="headerlink" title="存储引擎（高薪常问）"></a>存储引擎（高薪常问）</h2><h3 id="3-5-1-概念"><a href="#3-5-1-概念" class="headerlink" title="*3.5.1* *概念*"></a><em><strong>*3.5.1*</strong></em> <em><strong>*<strong>概念</strong>*</strong></em></h3><p>数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建.查询. 更新和删除数据。不同的存储引擎提供不同的存储机制.</p>
<p>索引技巧.锁定水平等功能，使用不同 的存储引擎，还可以 获得特定的功能。<br>        现在许多不同的数据库管理系统都支持多种不同的数据引擎。</p>
<p>存储引擎主要有： 1. MyIsam , 2. InnoDB, 3. Memory, 4. Archive, 5.Federated 。</p>
<h3 id="3-5-2-InnoDB"><a href="#3-5-2-InnoDB" class="headerlink" title="*3.5.2* *InnoDB*"></a><em><strong>*3.5.2*</strong></em> <strong>*InnoDB*</strong></h3><p>InnoDB 底层存储结构为B+树，B 树的每个节点对应innodb 的一个page， page 大小是固定的， 一般设为 16k。其中非叶子节点只有键值，叶子节点包含完成数据。</p>
<p>适 用 场 景 ：</p>
<p>1）经常更新的表，适合处理多重并发的更新请求。</p>
<p>2）支持事务。</p>
<p>3）可以从灾难中恢复（通过 bin-log 日志等）。</p>
<p>4）外键约束。只有他支持外键。       </p>
<p>5）支持自动增加列属性 auto_increment。</p>
<h3 id="3-5-3-TokuDB"><a href="#3-5-3-TokuDB" class="headerlink" title="*3.5.3* *TokuDB*"></a><em><strong>*3.5.3*</strong></em> <strong>*TokuDB*</strong></h3><p>TokuDB 底层存储结构为 Fractal Tree,Fractal Tree 的结构与 B+树有些类似, 在 Fractal Tree 中，每一个 child 指针除了需要指向一个 child 节点外， 还会带有一个 Message Buffer ，这个 Message Buffer 是一个 FIFO 的队列， 用来缓存更新操作。</p>
<p>例如，一次插入操作只需要落在某节点的 Message Buffer 就可以马上返回了，并不需要搜索到叶 子节点。这些缓存的更新会在查询时或后台异步合并应用到对应的节点中。</p>
<p>TokuDB 在线添加索引，不影响读写操作, 非常快的写入性能，</p>
<p>Fractal-tree 在事务实现上有优势。 他主要适用于访问频率不高的数据或历史数据归档。</p>
<h3 id="3-5-4-MyIASM"><a href="#3-5-4-MyIASM" class="headerlink" title="*3.5.4* *MyIASM*"></a><em><strong>*3.5.4*</strong></em> <strong>*MyIASM*</strong></h3><p>​    MyIASM 是 MySQL 默认的引擎，但是它没有提供对数据库事务的支持， 也不支持行级锁和外键， 因此当 INSERT(插入)或 UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。</p>
<p>​    ISAM 执行读取操作的速度很快，而且不占用大量的内存和存储资源。在设计之初就预想数据组织 成有固定长度的记录，按顺序存储的。—ISAM 是一种静态索引结构。 缺点是它不 支持事务处理。</p>
<h3 id="3-5-5-Memory"><a href="#3-5-5-Memory" class="headerlink" title="*3.5.5* *Memory*"></a><em><strong>*3.5.5*</strong></em> <em><strong>*<em>Memory</em>*</strong></em></h3><p>Memory（也叫 HEAP）堆内存：使用存在内存中的内容来创建表。每个MEMORY 表只实际对应 一个磁盘文件。MEMORY 类型的表访问非常得快， 因为它的数据是放在内存中的，并且默认使用 HASH 索引。但是一旦服务关闭， 表中的数据就会丢失掉。 Memory 同时支持散列索引和 B 树索 引，B 树索引可以使用部分查询和通配查询，也可以使用和&gt;=等操作符方便数据挖掘，散列索 引相等的比较快但是对于范围的比较慢很多。</p>
<h2 id="索引（高薪常问）"><a href="#索引（高薪常问）" class="headerlink" title="索引（高薪常问）"></a>索引（<em>高薪常问</em>）</h2><p>索引（Index）是帮助 MySQL 高效获取数据的数据结构。常见的查询算法, 顺序查找,二分查找,二 叉排序树查找,哈希散列法,分块查找,平衡多路搜索树 B 树（B-tree）</p>
<p>索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。</p>
<p>MySQL 数据库几个基本的索引类型：普通索引.唯一索引.主键索引.全文索引.组合索引</p>
<h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>是最基本的索引，它没有任何限制。它有以下几种创建方式：</p>
<p><strong>（1）</strong> <em><strong>*直接创建索引*</strong></em></p>
<p>CREATE INDEX index_name ON table(column[length]))</p>
<p><strong>（2）</strong> <em><strong>*修改表结构的方式添加索引*</strong></em></p>
<p>ALTER TABLE table_name ADD INDEX index_name ON (column[length]))</p>
<p><strong>（3）</strong> <img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps6BA9.tmp.png" alt="img"><em><strong>*创建表的时候同时创建索引*</strong></em></p>
<table>
<thead>
<tr>
<th>1</th>
<th>CREATE TABLE <code>table</code> (</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td><code>id</code> int(11) NOT NULL AUTO_INCREMENT ,</td>
</tr>
<tr>
<td>3</td>
<td><code>title</code> char(255) CHARACTER NOT NULL ,</td>
</tr>
<tr>
<td>4</td>
<td><code>content</code> text CHARACTER NULL ,</td>
</tr>
<tr>
<td>5</td>
<td><code>time</code> int(10) NULL DEFAULT NULL ,</td>
</tr>
<tr>
<td>6</td>
<td>PRIMARY KEY (<code>id</code>)</td>
</tr>
<tr>
<td>7</td>
<td>INDEX index_name (title[length])</td>
</tr>
<tr>
<td>8</td>
<td>)</td>
</tr>
</tbody></table>
<p><strong>（4）</strong> <strong>删除索引</strong></p>
<p>DROP INDEX index_name ON table</p>
<h3 id="3-6-2-唯一索引"><a href="#3-6-2-唯一索引" class="headerlink" title="*3.6.2* *唯一索引*"></a><em><strong>*3.6.2*</strong></em> <em><strong>*唯一索引*</strong></em></h3><p>与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：</p>
<p>（1） 创建唯一索引</p>
<p>CREATE UNIQUE INDEX indexName ON table(column[length])</p>
<p>（2） 修改表结构</p>
<p>ALTER TABLE table_name ADD UNIQUE indexName ON (column[length])</p>
<p>（3） 创建表的时候直接指定</p>
<table>
<thead>
<tr>
<th>1</th>
<th>CREATE TABLE <code>table</code> (</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td><code>id</code> int(11) NOT NULL AUTO_INCREMENT ,</td>
</tr>
<tr>
<td>3</td>
<td><code>title</code> char(255) CHARACTER NOT NULL ,</td>
</tr>
<tr>
<td>4</td>
<td><code>content</code> text CHARACTER NULL ,</td>
</tr>
<tr>
<td>5</td>
<td><code>time</code> int(10) NULL DEFAULT NULL ,</td>
</tr>
<tr>
<td>6</td>
<td>UNIQUE indexName (title[length])</td>
</tr>
<tr>
<td>7</td>
<td>);</td>
</tr>
</tbody></table>
<h3 id="3-6-3-主键索引"><a href="#3-6-3-主键索引" class="headerlink" title="*3.6.3 主键索引*"></a><em><strong>*3.6.3 主键索引*</strong></em></h3><p>是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引：</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps6BAA.tmp.png" alt="img"> </p>
<h3 id="3-6-4-组合索引"><a href="#3-6-4-组合索引" class="headerlink" title="*3.6.4* *组合索引*"></a><em><strong>*3.6.4*</strong></em> <em><strong>*组合索引*</strong></em></h3><p>指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合</p>
<p>ALTER TABLE <code>table</code> ADD INDEX name_city_age (name,city,age);</p>
<h3 id="3-6-5-全文索引"><a href="#3-6-5-全文索引" class="headerlink" title="*3.6.5* *全文索引*"></a><em><strong>*3.6.5*</strong></em> <em><strong>*全文索引*</strong></em></h3><p>主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext 索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的 where 语句的参数匹配。fulltext 索引配合 match against 操作使用，而不是一般的 where 语句加 like。它可以在 create table，alter table ，create index 使用，不过目前只有 char.varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用 CREATE index 创建 fulltext 索引，要比先为一张表建立 fulltext 然后再将数据写入的速度快很多。</p>
<table>
<thead>
<tr>
<th>1</th>
<th>CREATE TABLE <code>table</code> (</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td><code>id</code> int(11) NOT NULL AUTO_INCREMENT ,</td>
</tr>
<tr>
<td>3</td>
<td><code>title</code> char(255) CHARACTER NOT NULL ,</td>
</tr>
<tr>
<td>4</td>
<td><code>content</code> text CHARACTER NULL ,</td>
</tr>
<tr>
<td>5</td>
<td><code>time</code> int(10) NULL DEFAULT NULL ,</td>
</tr>
</tbody></table>
<p>（1） 创建表的适合添加全文索引</p>
<p>（2） <img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps6BBB.tmp.png" alt="img">修改表结构添加全文索引</p>
<p>ALTER TABLE article ADD FULLTEXT index_content(content)</p>
<p>（3） 直接创建全文索引</p>
<p>CREATE FULLTEXT INDEX index_content ON article(content)</p>
<h3 id="3-6-6-索引的优点"><a href="#3-6-6-索引的优点" class="headerlink" title="*3.6.6* *索引的优点*"></a><em><strong>*3.6.6*</strong></em> <em><strong>*索引的优点*</strong></em></h3><p>创建唯一索引，保证数据库表中每一行数据的唯一性大大加快数据的检索速度，这也是创建索引的最主要的原因</p>
<p>加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排</p>
<p>序的时间。</p>
<p>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。</p>
<h3 id="3-6-7-索引的缺点"><a href="#3-6-7-索引的缺点" class="headerlink" title="*3.6.7* *索引的缺点*"></a><em><strong>*3.6.7*</strong></em> <em><strong>*索引的缺点*</strong></em></h3><p>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</p>
<p>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大</p>
<p>当对表中的数据进行增加.删除和修改的时候，索引也要动态的维护，降低了数据的维护速度</p>
<h3 id="3-6-8-常见索引原则"><a href="#3-6-8-常见索引原则" class="headerlink" title="*3.6.8* *常见索引原则*"></a><em><strong>*3.6.8*</strong></em> <em><strong>*常见索引原则*</strong></em></h3><p>选择唯一性索引：唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。</p>
<p>为经常需要排序.分组和联合操作的字段建立索引. 为常作为查询条件的字段建立索引。</p>
<p>限制索引的数目：越多的索引，会使更新表变得很浪费时间。</p>
<p>尽量使用数据量少的索引：如果索引的值很长，那么查询的速度会受到影响。尽量使用前缀来索引：如果索引字段的值很长，最好使用值的前缀来索引。删除不再使用或者很少使用的索引</p>
<p>最左前缀匹配原则，非常重要的原则。</p>
<p>尽量选择区分度高的列作为索引：区分度的公式是表示字段不重复的比例索引列不能参与计算，保持列“干净”：带函数的查询不参与索引。</p>
<p>尽量的扩展索引，不要新建索引。</p>
<h2 id="索引原理（了解）"><a href="#索引原理（了解）" class="headerlink" title="索引原理（了解）"></a>索引原理（了解）</h2><p>我们使用索引，就是为了提高查询的效率，如同查书一样，先找到章，再找到章中对于的小节，再找到具体的页码，再到我们需要的内容。</p>
<p>事实上索引的本质就是不断缩小获取数据的筛选范围，找出我们想要的结果。同时把随机的事件变成顺序的事件，也就是说有了这种索引机制，我们就可以总是用同一种查找方式来锁定数据。</p>
<p>数据库也是一样，但显然要复杂的多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的。而数据库实现比较复杂，一方面数据是保存在磁盘上的，另外一方面为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。</p>
<h3 id="3-7-1-磁盘IO与预读"><a href="#3-7-1-磁盘IO与预读" class="headerlink" title="*3.7.1* *磁盘IO与预读*"></a><em><strong>*3.7.1*</strong></em> <em><strong>*磁盘IO与预读*</strong></em></h3><p>磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS（Million Instructions Per Second）的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行约450万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。下图是计算机硬件延迟的对比图，供大家参考：</p>
<p> <img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps6BBC.tmp.jpg" alt="img"></p>
<p>考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，****当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内****，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p>
<h3 id="3-7-2-B-树"><a href="#3-7-2-B-树" class="headerlink" title="*3.7.2* *B+树*"></a><em><strong>*3.7.2*</strong></em> <em><strong>*B+树*</strong></em></h3><p>上面说了磁盘io是很费时间的。当我们想要查询一个数据的时候，应该控制把磁盘IO控制在一个很小的数量级。而B+数应运而生（B+树是通过二叉查找树，再由平衡二叉树，B树演化而来）。<img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps6BBD.tmp.jpg" alt="img"></p>
<p>如上图，是一颗b+树，关于b+树的定义可以参见<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/B%2B%E6%A0%91">B+树</a>，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p>
<h3 id="3-7-3-B-树的查找过程"><a href="#3-7-3-B-树的查找过程" class="headerlink" title="*3.7.3 B**+树的查找过程*"></a><em><strong>*3.7.3 B*</strong></em><em><strong>*+树的查找过程*</strong></em></h3><p>如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p>
<h3 id="3-7-4-B-树性质"><a href="#3-7-4-B-树性质" class="headerlink" title="3.7.4 B+树性质"></a><strong>3.7.4 B</strong><strong>+树性质</strong></h3><p>1****.索引字段要尽量的小*<em><strong>：通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。<br>        2.</strong></em>*索引的最左匹配特性****：当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p>
<h3 id="3-7-5-聚焦索引和辅助索引"><a href="#3-7-5-聚焦索引和辅助索引" class="headerlink" title="*3.7.5* *聚焦索引和辅助索引*"></a><em><strong>*3.7.5*</strong></em> <em><strong>*聚焦索引和辅助索引*</strong></em></h3><p>在数据库中，B+树的高度一般都在2~4层，这也就是说查找某一个键值的行记录时最多只需要2到4次IO，这倒不错。</p>
<p>数据库中的B+树索引可以分为聚集索引（clustered index）和辅助索引（secondary index），</p>
<p>聚集索引与辅助索引相同的是：不管是聚集索引还是辅助索引，其内部都是B+树的形式，即高度是平衡的，叶子结点存放着所有的数据。</p>
<p>聚集索引与辅助索引不同的是：叶子结点存放的是否是一整行的信息</p>
<p><strong>1)</strong> <em><strong>*聚集索引*</strong></em></p>
<p>InnoDB存储引擎表示索引组织表，即表中数据按照主键顺序存放。而聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子结点存放的即为整张表的行记录数据，也将聚集索引的叶子结点称为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。</p>
<p>如果未定义主键，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚簇索引。</p>
<p>如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。</p>
<p>由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。在多少情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子节点上直接找到数据。此外由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值得查询。</p>
<p>聚集索引的好处</p>
<p>它对主键的排序查找和范围查找速度非常快，叶子节点的数据就是用户所要查询的数据。如用户需要查找一张表，查询最后的10位用户信息，由于B+树索引是双向链表，所以用户可以快速找到最后一个数据页，并取出10条记录</p>
<p>范围查询（range query），即如果要查找主键某一范围内的数据，通过叶子节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可</p>
<p><strong>2)</strong> <em><strong>*辅助索引*</strong></em></p>
<p>表中除了聚集索引外其他索引都是辅助索引（Secondary Index，也称为非聚集索引），与聚集索引的区别是：辅助索引的叶子节点不包含行记录的全部数据。</p>
<p>叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含一个书签（bookmark）。该书签用来告诉InnoDB存储引擎去哪里可以找到与索引相对应的行数据。</p>
<p>由于InnoDB存储引擎是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。</p>
<p>辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引，但只能有一个聚集索引。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶子级别的指针获得相应的主键索引的主键，然后再通过主键索引来找到一个完整的行记录。</p>
<p>举例来说，如果在一棵高度为3的辅助索引树种查找数据，那需要对这个辅助索引树遍历3次找到指定主键，如果聚集索引树的高度同样为3，那么还需要对聚集索引树进行3次查找，最终找到一个完整的行数据所在的页，因此一共需要6次逻辑IO访问才能得到最终的一个数据页。</p>
<h2 id="3-8-数据库三范式-必会"><a href="#3-8-数据库三范式-必会" class="headerlink" title="*3.8* *数据库三范式**(必会)*"></a><em><strong>*3.8*</strong></em> <em><strong>*数据库三范式*</strong></em><em><strong>*(必会)*</strong></em></h2><p>范式是具有最小冗余的表结构。3 范式具体如下：</p>
<h3 id="3-8-1-第一范式-1st-NF-－First-Normal-Fromate"><a href="#3-8-1-第一范式-1st-NF-－First-Normal-Fromate" class="headerlink" title="*3.8.1* *第一范式(1st* *NF* *－First Normal Fromate)*"></a><em><strong>*3.8.1*</strong></em> <em><strong>*第一范式(1st*</strong></em> <em><strong>*NF*</strong></em> <em><strong>*－First Normal Fromate)*</strong></em></h3><p>第一范式的目标是确保每列的原子性:如果每列都是不可再分的最小数据单元（也称为最小的原子  单元），则满足第一范式（1NF）</p>
<p>第一范式（1NF）要求数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值。</p>
<p>若某一列有多个值，可以将该列单独拆分成一个实体，新实体和原实体间是一对多的关系。 </p>
<p>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。</p>
<p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</p>
<p>第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份.城市.详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式</p>
<h3 id="3-8-2-第二范式-2nd-NF－Second-Normal-Fromate"><a href="#3-8-2-第二范式-2nd-NF－Second-Normal-Fromate" class="headerlink" title="*3.8.2* *第二范式(2nd* *NF－Second Normal Fromate)*"></a><em><strong>*3.8.2*</strong></em> <em><strong>*第二范式(2nd*</strong></em> <em><strong>*NF－Second Normal Fromate)*</strong></em></h3><p>首先满足第一范式，并且表中非主键列不存在对主键的部分依赖。 第二范式要求每个表只描述一 件事情。</p>
<p>满足第二范式（2NF）必须先满足第一范式（1NF）。</p>
<p>第二范式要求实体中没一行的所有非主属性都必须完全依赖于主键；即：非主属性必须完全依赖于主键。</p>
<p>完全依赖：主键可能由多个属性构成，完全依赖要求不允许存在非主属性依赖于主键中的某一部分属性。</p>
<p>若存在哪个非主属性依赖于主键中的一部分属性，那么要将发生部分依赖的这一组属性单独新建一个实体，并且在旧实体中用外键与新实体关联，并且新实体与旧实体间是一对多的关系。</p>
<p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保 存在同一张数据库表中。</p>
<h3 id="3-8-3-第三范式-3rd-NF-－-Third-Normal-Fromate"><a href="#3-8-3-第三范式-3rd-NF-－-Third-Normal-Fromate" class="headerlink" title="*3.8.3* *第三范式(3rd* *NF**－* *Third Normal Fromate)*"></a><em><strong>*3.8.3*</strong></em> <em><strong>*第三范式(3rd*</strong></em> <em><strong>*NF*</strong></em><em><strong>*－*</strong></em> <em><strong>*Third Normal Fromate)*</strong></em></h3><p>第三范式定义是，满足第二范式，并且表中的列不存在对非主键列的传递依赖。除了主键订单编号外，顾客姓名依赖于非主键顾客编号。</p>
<p>满足第三范式必须先满足第二范式。</p>
<p>第三范式要求：实体中的属性不能是其他实体中的非主属性。因为这样会出现冗余。即：属性不依赖于其他非主属性。</p>
<p>如果一个实体中出现其他实体的非主属性，可以将这两个实体用外键关联， 而不是将另一张表的非主属性直接写在当前表中。</p>
<p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</p>
<h2 id="3-9-数据库事务-必会"><a href="#3-9-数据库事务-必会" class="headerlink" title="*3.9* *数据库事务**(必会)*"></a><em><strong>*3.9*</strong></em> <em><strong>*数据库事务*</strong></em><em><strong>*(必会)*</strong></em></h2><h3 id="3-9-1-事务-TRANSACTION"><a href="#3-9-1-事务-TRANSACTION" class="headerlink" title="*3.9.1* *事务(TRANSACTION)*"></a><em><strong>*3.9.1*</strong></em> <em><strong>*事务(TRANSACTION)*</strong></em></h3><p>​    是作为单个逻辑工作单元执行的一系列操作，这些操作作为一个整体一起向系统提交，要么都执行.要么都不执行。事务是一个不可分割的工作逻辑单元 事务必须具备以下四个属性，简称 ACID 属性：</p>
<p>A  ****原子性（Atomicity）****：事务是一个完整的操作。事务的各步操作是不可分的（原子的）；要  么都执行，要么都不执行。</p>
<p>B ****一致性（Consistency）****：当事务完成时，数据必须处于一致状态。</p>
<p>C  ****隔离性（Isolation）****：对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独 立的，它不应以任何方式依赖于或影响其他事务。</p>
<p>D  ****永久性（Durability）****：事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务 的永久性。</p>
<h3 id="3-9-2-事务控制语句"><a href="#3-9-2-事务控制语句" class="headerlink" title="3.9.2 事务控制语句"></a>3.9.2 事务控制语句</h3><p><em><strong>*BEGIN*</strong></em> 或 S<em><strong>*TART TRANSACTION*</strong></em> 显式地开启一个事务；</p>
<p><em><strong>*COMMIT*</strong></em> 也可以使用 <em><strong>*COMMIT WORK*<em><strong>，不过二者是等价的。</strong></em>*COMMIT*</strong></em> 会提交事务，并使已对数据库进行的所有修改成为永久性的；</p>
<p><em><strong>*ROLLBACK*</strong></em> 也可以使用 ****ROLLBACK WORK****，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</p>
<p><em><strong>*SAVEPOINT identifier*<em><strong>，</strong></em>*SAVEPOINT*</strong></em> 允许在事务中创建一个保存点，一个事务中可以有多个 ****SAVEPOINT****；</p>
<p><em><strong>*RELEASE SAVEPOINT identifier*</strong></em> 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</p>
<p><em><strong>*ROLLBACK TO identifier*</strong></em> 把事务回滚到标记点；</p>
<p><em><strong>*SET TRANSACTION*</strong></em> 用来设置事务的隔离级别。</p>
<p>InnoDB 存储引 擎 提 供 事 务 的 隔 离 级 别 有 <em><strong>*READ*</strong></em> <em><strong>*UNCOMMITTED.READ COMMITTED.REPEATABLE READ*</strong></em> 和 <em><strong>*SERIALIZABLE*</strong></em> 。</p>
<h3 id="3-9-3-MySQL-事务处理主要有两种方法："><a href="#3-9-3-MySQL-事务处理主要有两种方法：" class="headerlink" title="*3.9.3* *MySQL 事务处理主要有两种方法：*"></a><em><strong>*3.9.3*</strong></em> <em><strong>*MySQL 事务处理主要有两种方法：*</strong></em></h3><p>a) 用 BEGIN, ROLLBACK, COMMIT 来实现</p>
<p><strong>i.</strong> <em><strong>*BEGIN*</strong></em> 开始一个事务</p>
<p><strong>ii.</strong> <em><strong>*ROLLBACK*</strong></em> 事务回滚</p>
<p><strong>iii.</strong>   <em><strong>*COMMIT*</strong></em> 事务确认</p>
<p>b) 直接用 SET 来改变 MySQL 的自动提交模式:</p>
<p><strong>i.</strong> <em><strong>*SET*</strong></em> <em><strong>*AUTOCOMMIT=0*</strong></em> 禁止自动提交</p>
<p><strong>ii.</strong> <em><strong>*SET*</strong></em> <em><strong>*AUTOCOMMIT=1*</strong></em> 开启自动提交</p>
<h3 id="3-9-4-事务的四种隔离级别"><a href="#3-9-4-事务的四种隔离级别" class="headerlink" title="*3.9.4* *事务的四种隔离级别*"></a><em><strong>*3.9.4*</strong></em> <em><strong>*事务的四种隔离级别*</strong></em></h3><p><em><strong>*1）*</strong></em><em><strong>*Read uncommitted*</strong></em></p>
<p>读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。</p>
<p><em><strong>*2）*</strong></em><em><strong>*Read committed*</strong></em></p>
<p>读已提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数</p>
<p><em><strong>*3）*</strong></em><em><strong>*Repeatable read*</strong></em></p>
<p>可重复读，就是在开始读取数据（事务开启）时，不再允许修改操作</p>
<p><em><strong>*4）*</strong></em><em><strong>*Serializable 序列化*</strong></em></p>
<p>Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读.不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</p>
<p><strong>在</strong> <strong>MySQL</strong> <strong>数据库中，支持上面四种隔离级别，默认的为</strong> <strong>Repeatable read</strong> **(可重复读)**；而在 Oracle 数据库中，只支持 Serializable (串行化)级别和 Read committed (读已提交)这两种级别，其中默认的为 Read committed 级别。</p>
<h2 id="3-10-存储过程-（高薪常问）"><a href="#3-10-存储过程-（高薪常问）" class="headerlink" title="*3.10* *存储过程**（高薪常问）*"></a><em><strong>*3.10*</strong></em> <em><strong>*存储过程*</strong></em><em><strong>*（高薪常问）*</strong></em></h2><p>一组为了完成特定功能的 SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次 编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过 程是数据库中的一个重要对象。</p>
<p>存储过程优化思路：</p>
<p>\1. 尽量利用一些 SQL 语句来替代一些小循环，例如聚合函数，求平均函数等。</p>
<p>\2. 中间结果存放于临时表，加索引。</p>
<p>\3. 少使用游标。SQL 是个集合语言，对于集合运算具有较高性能。而cursors是<br>过程运算。比 如对一个 100 万行的数据进行查询。游标需要读表100 万次，而不<br>使用游标则只需要少量几次读取。</p>
<p>\4. 事务越短越好。SQLserver 支持并发操作。如果事务过多过长，或者隔离级<br>别过高，都会造 成并发操作的阻塞，死锁。导致查询极慢，cpu 占用率极地。</p>
<p>\5. 使用 try-catch 处理错误异常。</p>
<p>\6. 查找语句尽量不要放在循环内。</p>
<h2 id="3-11-数据库并发策略-（高薪常问）"><a href="#3-11-数据库并发策略-（高薪常问）" class="headerlink" title="*3.11* *数据库并发策略**（高薪常问）*"></a><em><strong>*3.11*</strong></em> <em><strong>*数据库并发策略*</strong></em><em><strong>*（高薪常问）*</strong></em></h2><p>并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳。</p>
<h3 id="3-1-1-1-乐观锁"><a href="#3-1-1-1-乐观锁" class="headerlink" title="*3.1**1**.1 乐观锁*"></a><em><strong>*3.1*</strong></em><em><strong>*1*</strong></em><em><strong>*.1 乐观锁*</strong></em></h3><p>乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自 己读数据库的时候，别人可能刚好在写自己刚读的数据， 其实就是持一种比较保守的态度；时间 戳就是不加锁，通过时间戳来控制并发出现的问题。</p>
<h3 id="3-11-2-悲观锁"><a href="#3-11-2-悲观锁" class="headerlink" title="*3.11.2* *悲观锁*"></a><em><strong>*3.11.2*</strong></em> <em><strong>*悲观锁*</strong></em></h3><p>悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加 锁，只有自己把数据读完了，才允许别人修改那部分数据， 或者反过来说，就是自己修改某条数 据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允 许其他用户访问那部分数据。</p>
<h3 id="3-11-3-两种锁的使用场景"><a href="#3-11-3-两种锁的使用场景" class="headerlink" title="*3.11.3* *两种锁的使用场景*"></a><em><strong>*3.11.3*</strong></em> <em><strong>*两种锁的使用场景*</strong></em></h3><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行 retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p>
<h3 id="3-11-4-乐观锁常见的两种实现式版本号机制"><a href="#3-11-4-乐观锁常见的两种实现式版本号机制" class="headerlink" title="3.11.4 乐观锁常见的两种实现式版本号机制"></a>3.11.4 乐观锁常见的两种实现式版本号机制</h3><p>一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数，当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。CAS 算法即 compare and swap（比较与交换），是一种有名的无锁算法。</p>
<p>无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS 算法涉及到三个操作数</p>
<p>需要读写的内存值 </p>
<p>V 进行比较的值 A</p>
<p>拟写入的新值 B</p>
<p>当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值， 否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p>
<h3 id="3-11-5-乐观锁的缺点"><a href="#3-11-5-乐观锁的缺点" class="headerlink" title="*3.11.5* *乐观锁的缺点*"></a><em><strong>*3.11.5*</strong></em> <em><strong>*乐观锁的缺点*</strong></em></h3><p><em><strong>*ABA 问 题*</strong></em></p>
<p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 “ABA”问题。</p>
<p>JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<p><em><strong>*循环时间长开销大*</strong></em></p>
<p>自旋 CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功， 会给 CPU 带来非常大的执行开销。 如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起 CPU 流水线被清空（CPU pipeline flush），从而提高 CPU 的执行效率。</p>
<p><em><strong>*只能保证一个共享变量的原子操作*</strong></em></p>
<p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了 AtomicReference 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用 AtomicReference 类把多个共享变量合并成一个共享变量来操作</p>
<p><em><strong>*CAS 与 synchronized 的使用情景*</strong></em></p>
<p>简单的来说 CAS 适用于写比较少的情况下（多读场景，冲突一般较少）， synchronized 适用于写比较多的情况下（多写场景，冲突一般较多）</p>
<p>对于资源竞争较少（线程冲突较轻）的情况，使用 synchronized 同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu 资源； 而 CAS 基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少， 因此可以获得更高的性能。</p>
<p>对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大， 从而浪费更多的 CPU 资源，效率低于 synchronized。</p>
<p>补充： Java 并发编程这个领域中 synchronized 关键字一直都是元老级的</p>
<p>角色，很久之前很多人都会称它为 “重量级锁” 。但是，在 JavaSE 1.6 之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。</p>
<p>synchronized 的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞， 竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较 少的情况下，可以获得和 CAS 类似的性能；而线程冲突严重的情况下，性能远高于 CAS<strong>。</strong></p>
<h3 id="3-11-6-时间戳"><a href="#3-11-6-时间戳" class="headerlink" title="*3.11.6* *时间戳*"></a><em><strong>*3.11.6*</strong></em> <em><strong>*时间戳*</strong></em></h3><p>时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字 段也读出来，当写回去的时候，把该字段加 1，提交之前 ， 跟数据库的该字段比较一次，如果比数 据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁 机制，但是这种方法可以大大提高数据库处理的并发量，</p>
<p>以上悲观锁所说的加“锁”，其实分为几种锁，分别是：排它锁（写锁）和共享锁（读锁）。</p>
<h2 id="3-12-触发器-（高薪常问）"><a href="#3-12-触发器-（高薪常问）" class="headerlink" title="*3.12* *触发器**（高薪常问）*"></a><em><strong>*3.12*</strong></em> <em><strong>*触发器*</strong></em><em><strong>*（高薪常问）*</strong></em></h2><p>触发器是一段能自动执行的程序，是一种特殊的存储过程，触发器和普通的存储过程的区别是： 触发器是当对某一个表进行操作时触发。诸如： update.insert.delete 这些操作的时候，系统 会自动调用执行该表上对应的触发器。SQL Server 2005 中触发器可以分为两类：DML 触发器和 DDL 触发器，其中 DDL 触发器它们会影响多种数据定义语言语句而激发，这些语句有create. alter.drop 语句。</p>
<h2 id="3-13-数据库锁-（高薪常问）"><a href="#3-13-数据库锁-（高薪常问）" class="headerlink" title="*3.13* *数据库锁**（高薪常问）*"></a><em><strong>*3.13*</strong></em> <em><strong>*数据库锁*</strong></em><em><strong>*（高薪常问）*</strong></em></h2><h3 id="3-13-1-行级锁"><a href="#3-13-1-行级锁" class="headerlink" title="*3.13.1* *行级锁*"></a><em><strong>*3.13.1*</strong></em> <em><strong>*行级锁*</strong></em></h3><p>行级锁是一种排他锁，防止其他事务修改此行；在使用以下语句时，Oracle 会自动应用行级锁：</p>
<p>INSERT.UPDATE.DELETE.SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT];</p>
<p>SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新</p>
<p>使用 COMMIT 或 ROLLBACK 语句释放锁。</p>
<h3 id="3-13-2-表级锁"><a href="#3-13-2-表级锁" class="headerlink" title="*3.13.2* *表级锁*"></a><em><strong>*3.13.2*</strong></em> <em><strong>*表级锁*</strong></em></h3><p>表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL 引擎支持。最常使 用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁 （排他锁）。</p>
<h3 id="3-13-3-页级锁"><a href="#3-13-3-页级锁" class="headerlink" title="*3.13.3* *页级锁*"></a><em><strong>*3.13.3*</strong></em> <em><strong>*页级锁*</strong></em></h3><p>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级 冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB 支持页级锁</p>
<h2 id="3-14-基于-Redis-分布式锁-（高薪常问）"><a href="#3-14-基于-Redis-分布式锁-（高薪常问）" class="headerlink" title="*3.14* *基于* *Redis* *分布式锁**（高薪常问）*"></a><em><strong>*3.14*</strong></em> <em><strong>*基于*</strong></em> <em><strong>*Redis*</strong></em> <em><strong>*分布式锁*</strong></em><em><strong>*（高薪常问）*</strong></em></h2><p>\1. 获取锁的时候，使用 setnx（ETNX key val：当且仅当 key 不存在时， set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0） 加锁，锁的 value 值为一个随机生成的 UUID，在释放锁的时候进行判断。并使用 expire 命令为锁添 加一个超时时间，超过该时间则自动释放锁。</p>
<p>\2. 获取锁的时候调用 setnx，如果返回 0，则该锁正在被别人使用，返回 1 则成功获取 锁。 还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</p>
<p>\3. 释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</p>
<h2 id="3-15-分区分表-（高薪常问）"><a href="#3-15-分区分表-（高薪常问）" class="headerlink" title="*3.15* *分区分表**（高薪常问）*"></a><em><strong>*3.15*</strong></em> <em><strong>*分区分表*</strong></em><em><strong>*（高薪常问）*</strong></em></h2><p>分库分表有垂直切分和水平切分两种。</p>
<p><strong>▪</strong> ****垂直切分****：将表按照功能模块.关系密切程度划分出来，部署到不同的库上。例如，我们会 建立定义数据库 workDB.商品数据库 payDB.用户数据库userDB.日志数据库 logDB 等，分别用于存储项目数据定义表.商品定义表.用户数据表.日志数据表等。</p>
<p><strong>▪</strong> ****水平切分****：当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如 userID 散列，进行划分，然后存储到多个结构相同的表，和不同的库上。例如，我们的 userDB 中的用户数据表中，每一个表的数据量都很大， 就可以把 userDB 切分为结构相同的多个 userDB：part0DB.part1DB 等，再将 userDB 上 的 用 户 数 据 表 userTable， 切 分 为 很 多 userTable： userTable0.userTable1 等，然后将这些表按照一定的规则存储到多个 userDB 上。</p>
<h2 id="3-16-应该使用哪一种方式来实施数据库分库分表，这要看数据库中数据量的瓶颈所在，并综合项目的业务类型进行考虑。-（了解）"><a href="#3-16-应该使用哪一种方式来实施数据库分库分表，这要看数据库中数据量的瓶颈所在，并综合项目的业务类型进行考虑。-（了解）" class="headerlink" title="*3.16* *应该使用哪一种方式来实施数据库分库分表，这要看数据库中数据量的瓶颈所在，并综合项目的业务类型进行考虑。**（了解）*"></a><em><strong>*3.16*</strong></em> <em><strong>*应该使用哪一种方式来实施数据库分库分表，这要看数据库中数据量的瓶颈所在，并综合项目的业务类型进行考虑。*</strong></em><em><strong>*（了解）*</strong></em></h2><p>如果数据库是因为表太多而造成海量数据，并且项目的各项业务逻辑划分清晰. 低耦合，那么规则简单明了.容易实施的垂直切分必是首选。</p>
<p>而如果数据库中的表并不多，但单表的数据量很大.或数据热度很高，这种情况 之下就应该选择水平切分，水平切分比垂直切分要复杂一些，它将原本逻辑上属 于一体的数据进行了物理分割，除了在分割时要对分割的粒度做好评估， 考虑数 据平均和负载平均，后期也将对项目人员及应用程序产生额外的数据管理负担。 在现实项目中，往往是这两种情况兼而有之，这就需要做出权衡，甚至既需要垂 直切分，又需要水平切分。我们的游戏项目便综合使用了垂直与水平切分，我们 首先对数据库进行垂直切分，然后，再针对一部分表，通常是用户数据表，进行 水平切分。</p>
<p>单库多表 ：</p>
<p>随着用户数量的增加，user 表的数据量会越来越大，当数据量达到一定 程度的时候对 user 表的查询会渐渐的变慢，从而影响整个 DB 的性能。如果使用 MySQL, 还有一个更严重的问题是，当需要添加一列的时候，MySQL 会锁表， 期间所有的读写操作只能等待。</p>
<p>可以将 user 进行水平的切分，产生两个表结构完全一样的user_0000,user_0001 等表，user_0000 + user_0001 + …的数据刚好是一份完整的数据。</p>
<p><em><strong>*多库多表*</strong></em> ：</p>
<p>随着数据量增加也许单台 DB 的存储空间不够，随着查询量的增加单台数据 库服务器已经没办法支撑。这个时候可以再对数据库进行水平区分。</p>
<p>分库分表规则举例： 通过分库分表规则查找到对应的表和库的过程。如分库分表的规则是 user_id 除以 4 的方式，当用户新注册了一个账号，账号 id 的 123,我们可以通过 id 除以 4 的方式确定此账号应该保存到 User_0003 表中。当用户 123 登录的时 候，我们通过 123 除以 4 后确定记录在User_0003 中 。</p>
<h2 id="3-17-MySQL-读写分离-（高薪常问）"><a href="#3-17-MySQL-读写分离-（高薪常问）" class="headerlink" title="*3.17* *MySQL* *读写分离**（高薪常问）*"></a><em><strong>*3.17*</strong></em> <em><strong>*MySQL*</strong></em> <em><strong>*读写分离*</strong></em><em><strong>*（高薪常问）*</strong></em></h2><p>在实际的应用中，绝大部分情况都是读远大于写。MySQL 提供了读写分离的机制，所有的写操作都必须对应到 Master，读操作可以在 Master 和 Slave 机 器上进行，Slave 与 Master 的结构完全一样，一个 Master 可以有多个Slave,甚 至 Slave 下还可以挂 Slave,通过此方式可以有效的提高 DB 集群的每秒查询率. 所有的写操作都是先在 Master 上操作，然后同步更新到 Slave上，所以 从 Master 同步到 Slave 机器有一定的延迟，当系统很繁忙的时候， 延迟问题会 更加严重，Slave 机器数量的增加也会使这个问题更加严重。此外，可以看出 Master 是集群的瓶颈，当写操作过多，会严重影响到Master 的 稳定性，如果 Master 挂掉，整个集群都将不能正常工作。 所以，</p>
<p>\1. 当读压力很大的时候，可以考虑添加 Slave 机器的分式解决，但是当 Slave 机器达到一定的数量就得考虑分库了。 </p>
<p>\2. 当写压力很大的时候，就必须 得进行分库操作。</p>
<h2 id="3-18-MySQL-常用-30-种-SQL-查询语句优化方法-必会"><a href="#3-18-MySQL-常用-30-种-SQL-查询语句优化方法-必会" class="headerlink" title="*3.18* *MySQL* *常用* *30* *种* *SQL* *查询语句优化方法**(必会)*"></a><em><strong>*3.18*</strong></em> <em><strong>*MySQL*</strong></em> <em><strong>*常用*</strong></em> <em><strong>*30*</strong></em> <em><strong>*种*</strong></em> <em><strong>*SQL*</strong></em> <em><strong>*查询语句优化方法*</strong></em><em><strong>*(必会)*</strong></em></h2><p>\1. 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</p>
<p>\2. 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
<p>\3. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。如：</p>
<p>select id from t where num is null</p>
<p>可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询：</p>
<p>select id from t where num=0</p>
<p>\4. 尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<p>select id from t where num=10 or num=20 </p>
<p>可以这样查询：</p>
<p>select id from t where num=10</p>
<p>union all</p>
<p>select id from t where num=20</p>
<p>\5. 下面的查询也将导致全表扫描：(不能前置百分号) </p>
<p>select id from t where name like ‘%c%’</p>
<p>下面走索引</p>
<p>select id from t where name like ‘c%’ </p>
<p>若要提高效率，可以考虑全文检索。</p>
<p>\6. in 和 not in 也要慎用，否则会导致全表扫描，如： </p>
<p>select id from t where num in(1,2,3)</p>
<p>对于连续的数值，能用 between 就不要用 in 了：</p>
<p>select id from t where num between 1 and 3</p>
<p>\7. 如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p>
<p>select id from t where num=@num </p>
<p>可以改为强制查询使用索引：</p>
<p>select id from t with(index(索引名)) where num=@num</p>
<p>\8. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<p>select id from t where num/2=100</p>
<p>应改为:</p>
<p>select id from t where num=100*2</p>
<p>\9. 应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<p>select id from t where substring(name,1,3)=’abc’ –name 以 abc 开头的 id</p>
<p>select id from t where datediff(day,createdate,’2005-11-30′)=0 –’ 2005-11-30′生成的 id</p>
<p>应改为:</p>
<p>select id from t where name like ‘abc%’</p>
<p>select id from t where createdate&gt;=’2005-11-30′ and createdate&lt;’ 2005-12-1′</p>
<p>\10. 不要在 where 子句中的“=”左边进行函数.算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
<p>\11. 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使 用，并且应尽可能的让字段顺序与索引顺序相一致。</p>
<p>\12. 不要写一些没有意义的查询，如需要生成一个空表结构：</p>
<p> select col1,col2 into #t from t where 1=0</p>
<p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： </p>
<p>create table #t(…)</p>
<p>\13.  很多时候用 exists 代替 in 是一个好的选择：</p>
<p>select num from a where num in(select num from b)</p>
<p>用下面的语句替换：</p>
<p>select num from a where exists(select 1 from b where num=a.num) </p>
<p>\14.   并不是所有索引对查询都有效，SQL 是根据表中数据来进行查询优化的，</p>
<p>当索引列有大量数据重复时，SQL 查询可能不会去利用索引，如一表中有字段sex，male.female 几乎各一半，那么即使在 sex 上建了索引也对查询效率起不了作用。</p>
<p>\15.  索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数较好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</p>
<p>\16.  应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p>
<p>\17.  尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型， 这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
<p>\18.  尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
<p>\19.  任何地方都不要使用  select * from  ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p>
<p>\20.  尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p>
<p>\21.  避免频繁创建和删除临时表，以减少系统表资源的消耗。</p>
<p>\22.  临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如， 当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，较好使 用导出表。</p>
<p>\23.  在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大， 为了缓和系统表的资源，应先 create table，然后 insert。</p>
<p>\24.  如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除， 先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p>
<p>\25.  尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过 1 万行，那么就应该考虑改写。</p>
<p>\26.  使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p>
<p>\28.  与临时表一样，游标并不是不可使用。对小型数据集使用FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p>
<p>\29.  在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONEINPROC 消息。</p>
<p>\29. <img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps6BCD.tmp.jpg" alt="img"> 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p>
<p>\30.  尽量避免大事务操作，提高系统并发能力。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sixwudou.github.io/2022/02/12/JavaWeb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.gif">
      <meta itemprop="name" content="毋  豆">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="毋  豆 Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/12/JavaWeb/" class="post-title-link" itemprop="url">JavaWeb</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-12 16:12:01 / 修改时间：16:37:38" itemprop="dateCreated datePublished" datetime="2022-02-12T16:12:01+08:00">2022-02-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h1><h2 id="JDBC-技术"><a href="#JDBC-技术" class="headerlink" title="JDBC 技术"></a>JDBC 技术</h2><h3 id="说下原JDBC操作数据库流程？"><a href="#说下原JDBC操作数据库流程？" class="headerlink" title="说下原JDBC操作数据库流程？"></a>说下原JDBC操作数据库流程？</h3><ul>
<li><p>Class.forName()加载数据库连接驱动；</p>
</li>
<li><p>DriverManager.getConnection()获取数据连接对象;</p>
</li>
<li><p>根据SQL获取sql会话对象，有2种方式Statement.Prepared Statement ;</p>
</li>
<li><p>执行 SQL 处理结果集，执行 SQL 前如果有参数值就设置参数值 setXXX();</p>
</li>
<li><p>关闭结果集.关闭会话.关闭连接。</p>
</li>
</ul>
<h3 id="说说事务的概念，在JDBC编程中处理事务的步骤。"><a href="#说说事务的概念，在JDBC编程中处理事务的步骤。" class="headerlink" title="说说事务的概念，在JDBC编程中处理事务的步骤。"></a>说说事务的概念，在JDBC编程中处理事务的步骤。</h3><ul>
<li>事务是作为单个逻辑工作单元执行的一系列操作。</li>
<li>一个逻辑工作单元必须有四个属性，称为原子性.一致性.隔离性和持久性 (ACID) 属性，只有这样才能成为一个事务处理步骤：</li>
<li>conn.setAutoComit(false);设置提交方式为手工提交</li>
<li> conn.commit()提交事务</li>
<li>异常，回滚 conn.rollback();</li>
</ul>
<h3 id="JDBC的脏读是什么？哪种数据库隔离级别能防止脏读？"><a href="#JDBC的脏读是什么？哪种数据库隔离级别能防止脏读？" class="headerlink" title="JDBC的脏读是什么？哪种数据库隔离级别能防止脏读？"></a>JDBC的脏读是什么？哪种数据库隔离级别能防止脏读？</h3><p>当我们使用事务时，有可能会出现这样的情况，有一行数据刚更新，与此同时另一个查询读到了这个刚更新的值。这样就导致了脏读，因为更新的数据还没有进行持久化，更新这行数据的业务可能会进行回滚，这样这个数据就是无效的。数据库的 TRANSACTIONREADCOMMITTED ，TRANSACTIONREPEATABL</p>
<p>EREAD 和 TRANSACTION_SERIALIZABLE 隔离级别可以防止脏读。</p>
<h2 id="网路通讯部分"><a href="#网路通讯部分" class="headerlink" title="网路通讯部分"></a>网路通讯部分</h2><h3 id="TCP与UDP区别？"><a href="#TCP与UDP区别？" class="headerlink" title="TCP与UDP区别？"></a>TCP与UDP区别？</h3><p>UDP:  </p>
<ul>
<li>是面向无连接, 将数据及源的封装成数据包中,不需要建立连接</li>
<li>每个数据报的大小在限制64k内</li>
<li>因无连接,是不可靠协议</li>
<li>不需要建立连接,速度快</li>
</ul>
<p>TCP： </p>
<ul>
<li>建立连接,形成传输数据的通道.</li>
<li>在连接中进行大数据量传输，以字节流方式</li>
<li>通过三次握手完成连接,是可靠协议</li>
<li>必须建立连接效率会稍低.聊天.网络视频会议就是UDP</li>
</ul>
<h3 id="说一下什么是Http协议？"><a href="#说一下什么是Http协议？" class="headerlink" title="说一下什么是Http协议？"></a>说一下什么是Http协议？</h3><p>客户端和 服务器端之间数据传输的格式规范，格式简称为“超文本传输协议”。是一个基于请求与响应模式的.无状态的.应用层的协议，基于TCP的连接方式。</p>
<h3 id="get与post请求区别？"><a href="#get与post请求区别？" class="headerlink" title="get与post请求区别？"></a>get与post请求区别？</h3><p><em><strong>*区别1:*</strong></em></p>
<p>get重点在从服务器上获取资源，post重点在向服务器发送数据；</p>
<p><em><strong>*区别2：*</strong></em></p>
<p>get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用”?”连接，多个请求数据间用”&amp;”连接，如<a target="_blank" rel="noopener" href="http://127.0.0.1/Test/LogI">http://127.0.0.1/Test/LogI</a></p>
<p>n.action?name=admin&amp;password=admin，这个过程用户是可见的；</p>
<p>post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；</p>
<p><em><strong>*区别3：*</strong></em></p>
<p>Get传输的数据量小，因为受URL长度限制，但效率较高；</p>
<p>Post可以传输大量数据，所以上传文件时只能用Post方式；</p>
<p><em><strong>*区别4：*</strong></em></p>
<p>Get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等；</p>
<p>Post较get安全性较高；</p>
<p><em><strong>*区别5：*</strong></em></p>
<p>get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。</p>
<p>post支持标准字符集，可以正确传递中文字符。</p>
<h3 id="http中重定向和请求转发的区别？"><a href="#http中重定向和请求转发的区别？" class="headerlink" title="http中重定向和请求转发的区别？"></a>http中重定向和请求转发的区别？</h3><p><strong>本质区别：</strong>转发是服务器行为，重定向是客户端行为。</p>
<p><strong>重定向特点：</strong>两次请求，浏览器地址发生变化，可以访问自己 web 之外的资源，传输的数据会丢失。</p>
<p><strong>请求转发特点：</strong>一次请求，浏览器地址不变，访问的是自己本身的 web 资源，传输的数据不会丢失。</p>
<h2 id="Cookie-和-Session"><a href="#Cookie-和-Session" class="headerlink" title="Cookie 和 Session"></a>Cookie 和 Session</h2><p>Cookie 是 web 服务器发送给浏览器的一块信息，浏览器会在本地一个文件中给每个 web 服务器存储 cookie。以后浏览器再给特定的 web 服务器发送请求时，同时会发送所有为该服务器存储的 cookie。</p>
<p>Session 是存储在 web 服务器端的一块信息。session 对象存储特定用户会话所需的属性及配置信息。当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。</p>
<p>Cookie 和 session 的不同点：</p>
<p>1.无论客户端做怎样的设置，session 都能够正常工作。当客户端禁用 cookie 时将无法使用 cookie。</p>
<p>2.在存储的数据量方面：session 能够存储任意的 java 对象，cookie 只能存储 String 类型的对象。</p>
<h2 id="Jsp和Servlet"><a href="#Jsp和Servlet" class="headerlink" title="Jsp和Servlet"></a>Jsp和Servlet</h2><h3 id="Servlet的执行流程"><a href="#Servlet的执行流程" class="headerlink" title="Servlet的执行流程"></a>Servlet的执行流程</h3><p>Servlet的执行流程也就是servlet的生命周期，当服务器启动的时候生命周期开始，然后通过init()《启动顺序根据web.xml里的startup-on-load来确定加载顺序》方法初始化servlet，再根据不同请求调用doGet或doPost方法，最后再通过destroy()方法进行销毁。</p>
<h3 id="Jsp和Servlet的区别"><a href="#Jsp和Servlet的区别" class="headerlink" title="Jsp和Servlet的区别"></a>Jsp和Servlet的区别</h3><p>你可以将JSP当做一个可扩充的HTML来对待。</p>
<p>虽然在本质上JSP文件会被服务器自动翻译为相应的Servlet来执行。</p>
<p>可以说Servlet是面向Java程序员而JSP是面向HTML程序员的，除此之外两者功能完全等价。</p>
<h3 id="JSP九大内置对象"><a href="#JSP九大内置对象" class="headerlink" title="JSP九大内置对象"></a>JSP九大内置对象</h3><p>pageContext ：只对当前jsp页面有效，里面封装了基本的request和session的对象<br>    Request ：对当前请求进行封装<br>    Session ：浏览器会话对象，浏览器范围内有效<br>    Application ：应用程序对象，对整个web工程都有效<br>    Out ：页面打印对象，在jsp页面打印字符串<br>    Response ：返回服务器端信息给用户<br>    Config ：单个servlet的配置对象，相当于servletConfig对象<br>    Page ：当前页面对象，也就是this<br>    Exception ：错误页面的exception对象，如果指定的是错误页面，这个就是异常对象</p>
<h3 id="JSP的三大指令"><a href="#JSP的三大指令" class="headerlink" title="JSP的三大指令"></a>JSP的三大指令</h3><p>Page ：指令是针对当前页面的指令<br>    Include ：用于指定如何包含另一个页面<br>    Taglib ：用于定义和指定自定义标签</p>
<h3 id="七大动作"><a href="#七大动作" class="headerlink" title="七大动作"></a>七大动作</h3><p>Forward：执行页面跳转，将请求的处理转发到另一个页面<br>    Param ：用于传递参数<br>    Include ：用于动态引入一个jsp页面<br>    Plugin ：用于下载javaBean或applet到客户端执行<br>    useBean ：使用javaBean<br>        setProperty ：修改javaBean实例的属性值<br>        getProperty ：获取javaBean实例的属性值</p>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><h3 id="谈谈你对-Ajax-的认识？（了解）"><a href="#谈谈你对-Ajax-的认识？（了解）" class="headerlink" title="谈谈你对 Ajax 的认识？（了解）"></a>谈谈你对 Ajax 的认识？（了解）</h3><p>Ajax 是一种创建交互式网页应用的的网页开发技术；“Asynchronous JavaScript and XML”的缩写。</p>
<h3 id="Ajax创建的过程？（了解）"><a href="#Ajax创建的过程？（了解）" class="headerlink" title="Ajax创建的过程？（了解）"></a>Ajax创建的过程？（了解）</h3><p>1.创建 XMLHttpRequest 对象,也就是创建一个异步调用对象</p>
<p>2.创建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、URL 及验证信息</p>
<p>3.设置响应 HTTP 请求状态变化的函数</p>
<p>4.发送 HTTP 请求</p>
<p>5.获取异步调用返回的数据</p>
<p>6.使用 JavaScript 和 DOM 实现局部刷新</p>
<h3 id="阐述一下异步加载-JS？（了解）"><a href="#阐述一下异步加载-JS？（了解）" class="headerlink" title="阐述一下异步加载 JS？（了解）"></a>阐述一下异步加载 JS？（了解）</h3><p>1.异步加载的方案: 动态插入 script 标签</p>
<p>2.通过 ajax 去获取 js 代码，然后通过 eval 执行</p>
<p>3.script 标签上添加 defer 或者 async 属性</p>
<p>4.创建并插入 iframe，让它异步执行 js</p>
<h3 id="ajax-请求时，如何解释-json-数据？（了解）"><a href="#ajax-请求时，如何解释-json-数据？（了解）" class="headerlink" title="ajax 请求时，如何解释 json 数据？（了解）"></a>ajax 请求时，如何解释 json 数据？（了解）</h3><p>使用 eval() 或者 JSON.parse() 鉴于安全性考虑，推荐使用 JSON.parse()更靠谱，对数据的安全性更好.</p>
<h3 id="jax-提交请求-默认是-异步还是同步-怎么改成同步？（了解）"><a href="#jax-提交请求-默认是-异步还是同步-怎么改成同步？（了解）" class="headerlink" title="jax 提交请求 默认是 异步还是同步,怎么改成同步？（了解）"></a>jax 提交请求 默认是 异步还是同步,怎么改成同步？（了解）</h3><p>控制 ajax 请求参数 async 属性的值可以切换成同步请求或异步请求。</p>
<p>同步请求：(false)同步请求即是当前发出请求后，浏览器什么都不能做，必须得等到请求完成返回数据之后，才会执行后续的代码，相当于是排队，前一个人办理完自己的事务，下一个人才能接着办。也就是说，JS 代码加载到当前 AJAX 的时候会把页面里所有的代码停止加载，页面处于一个假死状态，当这个 AJAX 执行完毕后才会继续运行其他代码页面解除假死状态。</p>
<p>异步请求：(true) 异步请求就当发出请求的同时，浏览器可以继续做任何事，Ajax 发送请求并不会影响页面的加载与用户的操作，相当于是在两条线上，各走各的，互不影响。</p>
<p>例子：</p>
<p>$.ajax({</p>
<p>url:”url”,</p>
<p>type:”post”,</p>
<p>async:false,</p>
<p>success:function(){代码}});           </p>
<h3 id="如何解决-ajax-跨域问题？（了解）"><a href="#如何解决-ajax-跨域问题？（了解）" class="headerlink" title="如何解决 ajax 跨域问题？（了解）"></a>如何解决 ajax 跨域问题？（了解）</h3><p>跨域问题来源于 JavaScript 的”同源策略”，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说 JavaScript 只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对 JS 和 ajax 的，html 本身没有跨域问题。</p>
<p><em><strong>*跨域问题解决方案*</strong></em></p>
<p>1.响应头添加 Header 允许访问</p>
<p>跨域资源共享（CORS）Cross-Origin Resource Sharing</p>
<p>这个跨域访问的解决方案的安全基础是基于”JavaScript 无法控制该 HTTP 头”它需要通过目标域返回的 HTTP 头来授权是否允许跨域访问</p>
<p>具体如下：</p>
<p>response.addHeader(‘Access-Control-Allow-Origin:*’);//允许所有来源访问</p>
<p>response.addHeader(‘Access-Control-Allow-Method:POST,GET’);//允许访问的方式</p>
<p>2、jsonp （只支持 get 请求不支持 post 请求）</p>
<p>用法：</p>
<p>①dataType 改为 jsonp</p>
<p>②jsonp : “jsonpCallback”（发送到后端实际例子：</p>
<p><a target="_blank" rel="noopener" href="http://a.a.com/a/FromServlet?userName=644064&amp;jsonpCallback=jQueryxxx%EF%BC%89">http://a.a.com/a/FromServlet?userName=644064&amp;jsonpCallback=jQueryxxx）</a></p>
<p>③后端获取 get 请求中的 jsonpCallback</p>
<p>④构造回调结构</p>
<p>3、httpClient 内部转发</p>
<p>实现原理例子：若想在 B 站点中通过 Ajax 访问 A 站点获取结果，固然有 ajax 跨域问题，但在 B 站点中访问 B 站点获取结果，不存在跨域问题，这种方式实际上是在 B 站点中 ajax 请求访问 B 站点的 HttpClient，再通过 HttpClient 转发请求获取 A 站点的数据结果。但这种方式产生了两次请求，效率低，但内部请求，抓包工具无法分析，安全</p>
<p>4、使用接口网关——nginx、springcloud zuul (互联网公司常规解决方案)</p>
<h3 id="Ajax-的优势（了解）"><a href="#Ajax-的优势（了解）" class="headerlink" title="Ajax 的优势（了解）"></a>Ajax 的优势（了解）</h3><p>通过异步模式，提升了用户体验。</p>
<p>优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用。</p>
<p>Ajax 引擎在客户端运行，承担了一部分本来由服务器承担的工作，从而减少了大用户量下的服务器负载。</p>
<h3 id="请介绍下-Jsonp-原理（了解）"><a href="#请介绍下-Jsonp-原理（了解）" class="headerlink" title="请介绍下 Jsonp 原理（了解）"></a>请介绍下 Jsonp 原理（了解）</h3><p>jsonp 的最基本的原理是：动态添加一个<script>标签，使用 script 标签的 src 属性没有跨域的限制的特点实现跨域。首先在客户端注册一个callback, 然后把 callback 的名字传给服务器。此时，服务器先生成 json 数据。 然后以 javascript 语法的方式，生成一个 function , function 名字就是传递上来的参数 jsonp。最后将 json 数据直接以入参的方式，放置到 function 中，这样就生成了一段 js 语法的文档，返回给客户端。客户端浏览器，解析 script 标签，并执行返回的 javascript 文档，此时数据作为参数，传入到了客户端预先定义好的 callback 函数里。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sixwudou.github.io/2022/02/10/MyBatis3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.gif">
      <meta itemprop="name" content="毋  豆">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="毋  豆 Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/10/MyBatis3/" class="post-title-link" itemprop="url">MyBatis3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-10 16:19:03" itemprop="dateCreated datePublished" datetime="2022-02-10T16:19:03+08:00">2022-02-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sixwudou.github.io/2022/02/10/MyBatis2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.gif">
      <meta itemprop="name" content="毋  豆">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="毋  豆 Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/10/MyBatis2/" class="post-title-link" itemprop="url">MyBatis2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-10 16:18:48" itemprop="dateCreated datePublished" datetime="2022-02-10T16:18:48+08:00">2022-02-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sixwudou.github.io/2022/02/10/MyBatis1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.gif">
      <meta itemprop="name" content="毋  豆">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="毋  豆 Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/10/MyBatis1/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-10 15:35:32 / 修改时间：17:01:05" itemprop="dateCreated datePublished" datetime="2022-02-10T15:35:32+08:00">2022-02-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="MyBatis是什么"><a href="#MyBatis是什么" class="headerlink" title="MyBatis是什么"></a>MyBatis是什么</h3><ul>
<li><p>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。</p>
</li>
<li><p>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p>
</li>
<li><p>MyBatis 可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（ Plain Old Java Objects，普通的Java对象）映射成数据库中的记录。</p>
</li>
</ul>
<h3 id="MyBatis历史"><a href="#MyBatis历史" class="headerlink" title="MyBatis历史"></a>MyBatis历史</h3><ul>
<li>原是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation 迁移到了Google Code，随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis ，代码于2013年11月迁移到Github（下载地址见后）。</li>
<li>iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。 iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）</li>
</ul>
<h3 id="为什么要使用MyBatis？"><a href="#为什么要使用MyBatis？" class="headerlink" title="为什么要使用MyBatis？"></a>为什么要使用MyBatis？</h3><ul>
<li><p>JDBC</p>
<ul>
<li>SQL夹在Java代码块里，耦合度高导致硬编码内伤</li>
<li>维护不易且实际开发需求中sql是有变化，频繁修改的情况多见<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vamFsbGVua3dvbmcvTGVhcm5NeUJhdGlzL3Jhdy9tYXN0ZXIvaW1hZ2UvMDEucG5n?x-oss-process=image/format,png" alt="img"></li>
</ul>
</li>
<li><p>Hibernate和JPA<br>– 长难复杂SQL，对于Hibernate而言处理也不容易<br>– 内部自动生产的SQL，不容易做特殊优化。<br>– 基于全映射的全自动框架，大量字段的POJO进行部分映射时比较困难，导致数据库性能下降。<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vamFsbGVua3dvbmcvTGVhcm5NeUJhdGlzL3Jhdy9tYXN0ZXIvaW1hZ2UvMDIucG5n?x-oss-process=image/format,png" alt="img"></p>
</li>
<li><p>MyBatis是一个半自动化的持久化层框架。</p>
<ul>
<li>对开发人员而言，核心sql还是需要自己优化</li>
<li>sql和java编码分开，功能边界清晰，一个专注业务、一个专注数据。<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vamFsbGVua3dvbmcvTGVhcm5NeUJhdGlzL3Jhdy9tYXN0ZXIvaW1hZ2UvMDMucG5n?x-oss-process=image/format,png" alt="img"></li>
</ul>
</li>
</ul>
<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><ul>
<li>在MySQL数据库创建一数据库实例<code>learnmybatis</code>，在其创建一张表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employee(</span><br><span class="line">	id INT(11) PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	last_name VARCHAR(255),</span><br><span class="line">	gender CHAR(1),</span><br><span class="line">	email VARCHAR(255)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>再插进一条随意数据，用于测试</p>
<ul>
<li>创建Maven工程，添加依赖</li>
</ul>
<p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建对应的JavaBean</li>
</ul>
<p>Employee.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String lastName;</span><br><span class="line">	<span class="keyword">private</span> String email;</span><br><span class="line">	<span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//getter and setter and toString()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建mybatis配置文件，sql映射文件</p>
<ul>
<li>MyBatis 的全局配置文件包含了影响 MyBatis 行为甚深的设置（ settings）和属性（ properties）信息、如数据库连接池信息等。指导着MyBatis进行工作。我们可以参照官方文件的配置示例。</li>
<li>映射文件的作用就相当于是定义Dao接口的实现类如何工作。这也是我们使用MyBatis时编写的最多的文件。</li>
</ul>
</li>
<li><p>mybatis全局配置文件</p>
</li>
</ul>
<p>mybatis-config.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta"> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/learnmybatis?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8<span class="symbol">&amp;amp;</span>serverTimezone=CTT&quot;</span> /&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 将我们写好的sql映射文件（EmployeeMapper.xml）一定要注册到全局配置文件（mybatis-config.xml）中 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;c01/EmployeeMapper.xml&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>sql映射文件</li>
</ul>
<p>EmployeeMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;abc&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">namespace:名称空间;通常指定为接口的全类名</span></span><br><span class="line"><span class="comment">id：唯一标识</span></span><br><span class="line"><span class="comment">resultType：返回值类型</span></span><br><span class="line"><span class="comment">#&#123;id&#125;：从传递过来的参数中取出id值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public Employee getEmpById(Integer id);</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.lun.c01.helloworld.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">		select id,last_name lastName,email,gender from employee where id = #&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>测试</li>
</ul>
<p>HelloWorldTest.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">getSqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		String resource = <span class="string">&quot;c01/mybatis-config.xml&quot;</span>;</span><br><span class="line">		InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 1、根据xml配置文件（全局配置文件）创建一个SqlSessionFactory对象 有数据源一些运行环境信息</span></span><br><span class="line"><span class="comment">	 * 2、sql映射文件；配置了每一个sql，以及sql的封装规则等。 </span></span><br><span class="line"><span class="comment">	 * 3、将sql映射文件注册在全局配置文件中</span></span><br><span class="line"><span class="comment">	 * 4、写代码：</span></span><br><span class="line"><span class="comment">	 * 		1）、根据全局配置文件得到SqlSessionFactory；</span></span><br><span class="line"><span class="comment">	 * 		2）、使用sqlSession工厂，获取到sqlSession对象使用他来执行增删改查</span></span><br><span class="line"><span class="comment">	 * 			一个sqlSession就是代表和数据库的一次会话，用完关闭</span></span><br><span class="line"><span class="comment">	 * 		3）、使用sql的唯一标志来告诉MyBatis执行哪个sql。sql都是保存在sql映射文件中的。</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2、获取sqlSession实例，能直接执行已经映射的sql语句</span></span><br><span class="line">		<span class="comment">// sql的唯一标识：statement Unique identifier matching the statement to use.</span></span><br><span class="line">		<span class="comment">// 执行sql要用的参数：parameter A parameter object to pass to the statement.</span></span><br><span class="line">		SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line"></span><br><span class="line">		SqlSession openSession = sqlSessionFactory.openSession();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Employee employee = openSession.selectOne(</span><br><span class="line">					<span class="string">&quot;abc.getEmpById&quot;</span>, <span class="number">1</span>);</span><br><span class="line">			System.out.println(employee);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			openSession.close();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口式编程"><a href="#接口式编程" class="headerlink" title="接口式编程"></a>接口式编程</h2><p><strong>日后主要用接口式编程</strong></p>
<p>HelloWorld-接口式编程</p>
<ul>
<li>创建一个Dao接口</li>
</ul>
<p>EmployeeMapper.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lun.c01.helloworld.bean.Employee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改Mapper文件（命名空间，id，returnType）</li>
</ul>
<p>EmployeeMapper2.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.lun.c01.helloworld.dao.EmployeeMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">namespace:名称空间;指定为接口的全类名</span></span><br><span class="line"><span class="comment">id：唯一标识</span></span><br><span class="line"><span class="comment">resultType：返回值类型</span></span><br><span class="line"><span class="comment">#&#123;id&#125;：从传递过来的参数中取出id值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public Employee getEmpById(Integer id);</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.lun.c01.helloworld.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">		select id,last_name lastName,email,gender from employee where id = #&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>HelloWorldTest.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="comment">// 1、获取sqlSessionFactory对象</span></span><br><span class="line">	SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">	<span class="comment">// 2、获取sqlSession对象</span></span><br><span class="line">	SqlSession openSession = sqlSessionFactory.openSession();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 3、获取接口的实现类对象</span></span><br><span class="line">		<span class="comment">//会为接口自动的创建一个代理对象，代理对象去执行增删改查方法</span></span><br><span class="line">		EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);</span><br><span class="line">		Employee employee = mapper.getEmpById(<span class="number">1</span>);</span><br><span class="line">		System.out.println(mapper.getClass());</span><br><span class="line">		System.out.println(employee);</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		openSession.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>接口式编程</p>
</li>
<li><ul>
<li>原生： Dao ====&gt; DaoImpl</li>
<li>mybatis： Mapper ====&gt; xxMapper.xml</li>
</ul>
</li>
<li><p>SqlSession代表和数据库的一次会话；用完必须关闭；</p>
</li>
<li><p>SqlSession和connection一样她都是非线程安全。每次使用都应该去获取新的对象。</p>
</li>
<li><p>mapper接口没有实现类，但是mybatis会为这个接口生成一个代理对象。<br>（将接口和xml进行绑定）<code>EmployeeMapper empMapper = sqlSession.getMapper(EmployeeMapper.class);</code></p>
</li>
<li><p>两个重要的配置文件：</p>
<ul>
<li>mybatis的全局配置文件：包含数据库连接池信息，事务管理器信息等…系统运行环境信息</li>
<li>sql映射文件：保存了每一个sql语句的映射信息：将sql抽取出来。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sixwudou.github.io/2022/02/10/java%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.gif">
      <meta itemprop="name" content="毋  豆">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="毋  豆 Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/10/java%E9%9D%A2%E7%BB%8F/" class="post-title-link" itemprop="url">java基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-10 14:26:32" itemprop="dateCreated datePublished" datetime="2022-02-10T14:26:32+08:00">2022-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-12 16:55:27" itemprop="dateModified" datetime="2022-02-12T16:55:27+08:00">2022-02-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="重载和重写的区别（了解）"><a href="#重载和重写的区别（了解）" class="headerlink" title="重载和重写的区别（了解）"></a>重载和重写的区别（了解）</h3><p><strong>重载</strong>： 发生在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 </p>
<p><strong>重写：</strong> 发生在父子类中，方法名，参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。 </p>
<h3 id="String和StringBuffer-StringBuilder-的区别是什么？String-为什么是不可变的？（必会）"><a href="#String和StringBuffer-StringBuilder-的区别是什么？String-为什么是不可变的？（必会）" class="headerlink" title="String和StringBuffer,StringBuilder 的区别是什么？String 为什么是不可变的？（必会）"></a>String和StringBuffer,StringBuilder 的区别是什么？String 为什么是不可变的？（必会）</h3><p><strong>可变性</strong> </p>
<p>简单的来说：String 类中使用 final 关键字字符数组保存字符串， private final char value[] ，所以 String对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在AbstractStringBuilder中也是使用字符数组保存字符串 char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。 </p>
<p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。 </p>
<p>AbstractStringBuilder.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] value; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count; </span><br><span class="line"></span><br><span class="line">AbstractStringBuilder() &#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123; </span><br><span class="line"></span><br><span class="line">value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity]; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程安全性</strong> </p>
<p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity.append.insert.indexOf 等公共 方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 </p>
<p><strong>性能</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] value; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count; </span><br><span class="line"></span><br><span class="line">AbstractStringBuilder() &#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123; </span><br><span class="line"></span><br><span class="line">value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity]; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。 </p>
<p>StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 </p>
<p><em><strong>*对于三者使用的总结：*</strong></em> </p>
<p>\1. 操作少量的数据 =&gt; 使用String </p>
<p>\2. 单线程操作字符串缓冲区下操作大量数据 =&gt; 使用StringBuilder </p>
<p>\3. 多线程操作字符串缓冲区下操作大量数据 =&gt; 使用StringBuffer </p>
<h3 id="自动装箱与拆箱-了解"><a href="#自动装箱与拆箱-了解" class="headerlink" title="自动装箱与拆箱*****(了解)*"></a>自动装箱与拆箱****<em><strong>*(了解)*</strong></em></h3><p>****装箱：****将基本类型用它们对应的引用类型包装起来； </p>
<p>****拆箱：****将包装类型转换为基本数据类型； </p>
<h3 id="与-equals-必会"><a href="#与-equals-必会" class="headerlink" title="== 与 equals(必会)"></a>== 与 equals(必会)</h3><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即: 判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。</p>
<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况,如下： </p>
<p>****情况1****：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。 </p>
<p>****情况2****：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">String a = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用 </span></span><br><span class="line"></span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样 </span></span><br><span class="line"></span><br><span class="line">String aa = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中 </span></span><br><span class="line"></span><br><span class="line">String bb = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (aa == bb) <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;aa==bb&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象 </span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;a==b&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a.equals(b)) <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;aEQb&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;true&quot;</span>); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>*说明：*</strong></em> </p>
<p>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的equals 方法比较的是对象的值。 </p>
<p>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</p>
<h3 id="关于final关键字的一些总结-必会"><a href="#关于final关键字的一些总结-必会" class="headerlink" title="关于final关键字的一些总结(必会)"></a>关于final关键字的一些总结(必会)</h3><p><em><strong>*final关键字主要用在三个地方：变量、方法、类。*</strong></em> </p>
<p>\1. 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 </p>
<p>\2. 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。 </p>
<p>\3. 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。 </p>
<p>在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。 </p>
<h3 id="Java-中的异常处理-了解"><a href="#Java-中的异常处理-了解" class="headerlink" title="Java 中的异常处理(了解)"></a>Java 中的异常处理(了解)</h3><p>在 Java 中，所有的异常都有一个共同的祖先java.lang包中的<strong>Throwable类</strong>。</p>
<p><em><strong>*Throwable：*</strong></em> 有两个重要的子类： <img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88B7.tmp.jpg" alt="img"></p>
<p><strong>Exception（异常）</strong> 和 <strong>Error（错误）</strong>，二者都是 Java 异常处理的重要子类，各自都包含大量子类。 </p>
<h3 id="error-和-exception-的区别-了解"><a href="#error-和-exception-的区别-了解" class="headerlink" title="error 和 exception 的区别?(了解)"></a>error 和 exception 的区别?(了解)</h3><p>Error 类和 Exception 类的父类都是 Throwable 类，他们的区别如下。 </p>
<p>Error 类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢出等。对于这类 错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。 </p>
<p>Exception 类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。 </p>
<p>Exception 类又分为运行时异常(Runtime Exception)和受检查的异常(CheckedException )，运行时异常。</p>
<h3 id="接口和抽象类的区别是什么-必会"><a href="#接口和抽象类的区别是什么-必会" class="headerlink" title="接口和抽象类的区别是什么(必会)"></a>接口和抽象类的区别是什么(必会)</h3><p>\1. 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），抽象类可以有非抽象的方法。 </p>
<p>\2. 接口中的实例变量默认是 final 类型的，而抽象类中则不一定。 </p>
<p>\3. 一个类可以实现多个接口，但最多只能实现一个抽象类。 </p>
<p>\4. 一个类实现接口的话要实现接口的所有方法，而抽象类不一定。 </p>
<p>\5. 接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。 </p>
<p>备注: 在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，必须重写，不然会报错。</p>
<h3 id="什么是单例模式？有几种？-必会"><a href="#什么是单例模式？有几种？-必会" class="headerlink" title="什么是单例模式？有几种？(必会)"></a>什么是单例模式？有几种？(必会)</h3><p>单例模式：某个类的实例在 多线程环境下只会被创建一次出来。</p>
<p>  单例模式有饿汉式单例模式、懒汉式单例模式和双检锁单例模式三种。</p>
<p>  ****饿汉式****：线程安全，一开始就初始化。</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88B8.tmp.jpg" alt="img"> </p>
<p>  ****懒汉式****：非线程安全，延迟初始化。</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88B9.tmp.jpg" alt="img"> </p>
<p>****双检锁****：线程安全，延迟初始化。</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88BA.tmp.jpg" alt="img"> </p>
<h3 id="手写冒泡排序？-必会"><a href="#手写冒泡排序？-必会" class="headerlink" title="手写冒泡排序？(必会)"></a>手写冒泡排序？(必会)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> sort[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;请输入10个排序的数据：&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sort.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">			sort[i] = input.nextInt();</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sort.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sort.length - i - <span class="number">1</span>; j++) 			&#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (sort[j] &lt; sort[j + <span class="number">1</span>]) &#123;</span><br><span class="line"></span><br><span class="line">					temp = sort[j];</span><br><span class="line"></span><br><span class="line">					sort[j] = sort[j + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">					sort[j + <span class="number">1</span>] = temp;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;排列后的顺序为：&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sort.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">			System.out.print(sort[i]+<span class="string">&quot;======&quot;</span>);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		sort();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="BIO、NIO、AIO-有什么区别？-了解"><a href="#BIO、NIO、AIO-有什么区别？-了解" class="headerlink" title="BIO、NIO、AIO 有什么区别？(了解)"></a>BIO、NIO、AIO 有什么区别？(了解)</h3><p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。 </p>
<p>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。 </p>
<p>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p>
<h3 id="常见的数据结构有哪些？-了解"><a href="#常见的数据结构有哪些？-了解" class="headerlink" title="常见的数据结构有哪些？(了解)"></a>常见的数据结构有哪些？(了解)</h3><p>l 数组：</p>
<p><strong>**数组*<em><strong>是最常用的数据结构，数组的特点是</strong>长度固定</em>*，</strong>可以用下标索引<strong>，</strong>并且所有的元素的类型都是一致的**。数组常用的场景有：从数据库里读取雇员的信息存储为EmployeeDetail[ ];把一个字符串转换并存储到一个字节数组中便于操作和处理等等。尽量把数组封装在一个类里，防止数据被错误的操作弄乱。另外，这一点也适合其他的数据结构。</p>
<p>l 列表：</p>
<p><strong>**列表*<em><strong>和数组很相似，只不过它的</strong>大小可以改变</em>*。</strong>列表<strong>一般都是</strong>通过一个固定大小的数组<strong>来</strong>实现<strong>的，并且</strong>会<strong>在需要的时候</strong>自动调整大小<strong>。列表里</strong>可以包含重复的元素**。常用的场景有，添加一行新的项到订单列表里，把所有过期的商品移出商品列表等等。一般会把列表初始化成一个合适的大小，以减少调整大小的次数。</p>
<p>l 集合：</p>
<p>****集合*<em><strong>和列表很相似，不过它</strong>不能放重复的元素。</em>*</p>
<p>l 堆栈：</p>
<p><strong>**堆栈*<em><strong>只允许</strong>对最后插入</em>*的</strong>元素进行操作<strong>（也就是</strong>后进先出<strong>，Last In First Out – LIFO）。如果你移除了栈顶的元素，那么你可以操作倒数第二个元素，依次类推。这种后进先出的方式是通过仅有的</strong>peek(),push()和pop()<strong>这几个方法的</strong>强制性**限制达到的。</p>
<p>l 队列：</p>
<p><strong>**队列*<em><strong>和堆栈有些相似，不同之处在于在队列里</strong>第一个插入的元素也是第一个被删除的元素</em>*（即是</strong>先进先出**）。这种先进先出的结构是通过只提供peek()，offer()和poll()这几个方法来访问数据进行限制来达到的。例如，排队等待公交车，银行或者超市里的等待列队等等，都是可以用队列来表示。</p>
<p>l 链表：</p>
<p>链表是一种由****多个节点组成的****数据结构，并且每个节点包含有数据以及指向下一个节点的引用，在双向链表里，还会有一个指向前一个节点的引用。例如，可以用单向链表和双向链表来实现堆栈和队列，因为链表的两端都是可以进行插入和删除的动作的。当然，也会有在链表的中间频繁插入和删除节点的场景。Apache的类库里提供了一个TreeList的实现，它是链表的一个很好的替代，因为它只多占用了一点内存，但是性能比链表好很多。也就是说，从这点来看链表其实不是一个很好的选择。</p>
<h3 id="Java集合体系有什么-必会"><a href="#Java集合体系有什么-必会" class="headerlink" title="Java集合体系有什么?(必会)"></a>Java集合体系有什么?(必会)</h3><p>集合类存放于 Java.util 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)。 </p>
<p>\1. Collection：Collection 是集合 List、Set、Queue 的最基本的接口。 </p>
<p>\2. Iterator：迭代器，可以通过迭代器遍历集合中的数据。 </p>
<p>\3. Map：是映射表的基础接口。</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88BB.tmp.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88BC.tmp.jpg" alt="img"><strong>1. Iterator接口</strong></p>
<p>Iterator接口是一个用于遍历集合中元素的接口，主要包含****hashNext(),next(),remove()*<em><strong>三种方法。如果实现Iterator接口，那么在遍历集合中元素的时候，只能往后遍历，被遍历后的元素不会在遍历到，通常</strong>无序集合实现的都是这个接口</em>*，比如HashSet，HashMap</p>
<p><strong>2. LinkedIterator接口：</strong></p>
<p>LinkedIterator在Iterator的基础上又添加了****add(),previous(),hasPrevious()*<em><strong>三种方法，那些元素</strong></em>*有序的集合*<em><strong>，实现的</strong></em>*一般都是LinkedIterator接口*<em><strong>，实现这个接口的集合可以双向遍历，既可以通过</strong></em>*next()访问下一个元素*<em><strong>，又可以通过</strong></em>*previous()访问前一个元素****，比如ArrayList。</p>
<p><strong>3.Collection （集合的最大接口）继承关系</strong></p>
<p>l List 可以存放重复的内容</p>
<p>l Set 不能存放重复的内容，所以的重复内容靠hashCode()和equals()两个方法区分</p>
<p>l Queue 队列接口</p>
<p>l SortedSet可以对集合中的数据进行排序</p>
<p>Collection定义了集合框架的共性功能：</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88BD.tmp.jpg" alt="img"> </p>
<p>add方法的参数类型是Object。以便于接收任意类型对象。</p>
<p><em><strong>*集合中存储的都是对象的引用(地址)。*</strong></em></p>
<p><em><strong>*4.List*</strong></em></p>
<p>凡是可以操作角标的方法都是该体系特有的方法：</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88BE.tmp.jpg" alt="img"> </p>
<p>l ArrayList 线程不安全，查询速度快</p>
<p>l Vector 线程安全，但速度慢，已被ArrayList替代</p>
<p>l LinkedList 链表结果，增删速度快</p>
<p>l TreeList 树型结构，保证增删复杂度都是O（log n）,增删性能远高于ArrayList和    LinkedList,但是稍微占用内存</p>
<p><strong>5.Set</strong> </p>
<p>l Set：元素是<em><strong>*无序*</strong></em>(存入和取出的顺序不一定一致)，元素****不可以重复****。</p>
<p>u HashSet:<em><strong>*底层*<em><strong>数据结构是</strong></em>*哈希表*</strong></em><em><strong>*,*</strong></em> 是****线程不安全****的, 数据不同步。</p>
<p>u HashSet是如何****保证元素唯一性****的呢？</p>
<p>是通过元素的两个方法，****hashCode和equals****来完成。</p>
<p>如果元素的HashCode值相同，才会判断equals是否为true。</p>
<p>如果元素的hashcode值不同，不会调用equals。</p>
<p>注意,对于判断元素是否存在，以及删除等操作，依赖的方法是元素的    hashcode和equals方法。</p>
<p>l TreeSet：****底层*<em><strong>数据结构是</strong></em>*二叉树*<em><strong>，存放</strong></em>*有序*<em><strong>：TreeSet</strong></em>*线程不安全****可以对Set集合中的元素进行排序。通过compareTo或者compare方法来保证元素的唯一性。</p>
<p><strong>6.Map</strong> </p>
<p>Correction、Set、List接口都属于单值的操作，而Map中的每个元素都使用key——&gt;value的形式存储在集合中。</p>
<p>Map集合：该集合存储键值对, 是key:value一对一对往里存, 而且要保证键的唯一性。</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88CF.tmp.jpg" alt="img"> </p>
<p>Map接口的常用子类</p>
<p>l HashMap：****底层*<em><strong>数据结构是</strong></em>*哈希表****，允许使用 null 值和 null 键，该集合是数据不同步的，将hashtable替代，jdk1.2.效率高。</p>
<p>l TreeMap：<em><strong>*底层*<em><strong>数据结构是</strong></em>*二叉树*</strong></em>****，****线程不同步，可以用于给map集合中的键进行排序。</p>
<h3 id="List-的三个子类的特点-必会"><a href="#List-的三个子类的特点-必会" class="headerlink" title="List 的三个子类的特点(必会)"></a>List 的三个子类的特点(必会)</h3><p>ArrayList 底层结构是数组,底层查询快,增删慢 </p>
<p>LinkedList 底层结构是链表型的,增删快,查询慢 </p>
<p>Voctor 底层结构是数组 线程安全的,增删慢,查询慢</p>
<h3 id="List-和-Map、Set-的区别-必会"><a href="#List-和-Map、Set-的区别-必会" class="headerlink" title="List 和 Map、Set 的区别(必会)"></a>List 和 Map、Set 的区别(必会)</h3><p><strong>结构特点:</strong></p>
<p>List 和 Set 是存储单列数据的集合，Map 是存储键和值这样的双列数据的集合；</p>
<p>List 中存储的数据是有顺序，并且允许重复；</p>
<p>Map 中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的，Set中存储的数据是无序的，且不允许有重复，但元素在集合中的位置由元素的 hashcode 决定，位置是固定的（Set 集合根据 hashcode 来进行数据的存储，所以位置是固定的，但是位置不是用户可以控制的，所以对于用户来说 set 中的元素还是无序的）； </p>
<p><strong>实现类</strong> </p>
<p><strong>**List 接口*<em><strong>有三个实现类（</strong>LinkedList</em>*：基于链表实现，链表内存是散乱的，每一个元素存储本身内存地址的同时还存储下一个元素的地址。链表增删快，查找慢；</strong>ArrayList<strong>：基于数组实现，非线程安全的，效率高，便于索引，但不便于插入删除；</strong>Vector**：基于数组实现，线程安全的，效率低）。 </p>
<p><strong>**Map 接口*<em><strong>有三个实现类（</strong>HashMap</em>*：基于 hash 表的 Map 接口实现，非线程安全，高效，支持 null 值和 null键；</strong>HashTable<strong>：线程安全，低效，不支持 null 值和 null 键；</strong>LinkedHashMap**：是 HashMap 的一个子类，保存了记录的插入顺序；SortMap 接口：TreeMap，能够把它保存的记录根据键排序，默认是键值的升序排序）。 </p>
<p>****Set 接口*<em><strong>有两个实现类（</strong>HashSet</em>*：底层是由 HashMap 实现，不允许集合中有重复的值，使用该方式时需要重写 equals()和 hashCode()方法；LinkedHashSet：继承与 HashSet，同时又基于 LinkedHashMap 来进行实现，底层使用的是 LinkedHashMp）。</p>
<h3 id="1-16-HashMap底层实现原理-必会"><a href="#1-16-HashMap底层实现原理-必会" class="headerlink" title="1.16 HashMap底层实现原理(必会)"></a>1.16 HashMap底层实现原理(必会)</h3><p>HashMap根据键的hashCode值存储数据,大多数情况下可以直接定位到它的值.因而具有很快的访问速度,但是遍历顺序却不确定的.HashMap最多只允许一条记录的键为null,允许多条记录的值为null。</p>
<p>HashMap非线程安全,即任一时刻可以有多个线程同时写HashMap,可能会导致数据的不一致。</p>
<p>如果需要满足线程安全,可以用Collections的synchronizedMap方法使HashMap具有线程安全的能力,或者使用ConcurrentHashMap,HashTable.如下详细介绍。</p>
<p><strong>l</strong> <em><strong>*JDK1.8之前 (数组+链表)*</strong></em></p>
<p><strong>n</strong> <em><strong>*最开始存入数据的时候*</strong></em></p>
<p>\1. JDK1.8之前HashMap底层是数组和链表结合在一起使用,也就是链表散列.数组的长度规定是2的幂.数组中存放的对象是Entry&lt;key,value&gt;对象 ,不允许有重复的key存在,为什么呢?</p>
<p>\2. 首先,先判断key存放的位置, HashMap通过key的hashCode经过扰动函数处理过后得到hash值,然后通过(n-1)&amp;hash判断当前元素存放的位置(这里的n指的是数组的长度). 也可以理解:key%数组长度=对应数组的索引下标.然后将value存入到entry对象中。</p>
<p>所谓扰动函数知道就是HashMap的hash方法.使用hash方法也就是扰动函数是为了防止一些实现比较差的hashCode()方法,换句话说使用扰动函数之后可以减少碰撞。</p>
<p>\3. 为什么使用(n-1)&amp;length长度呢?</p>
<p>(1)保证数组不会越界:</p>
<p>首先我们要知道,在HashMap和ConcurrentHashMap中,数组的长度按规定一定是2的幂(2的n次方)因此,数组的长度的二进制形式是:10000…000,1后面有一堆0。那么tab.length - 1 的二进制形式就是01111…111，0后面有一堆1。最高位是0, 和hash值相”与”，结果值一定不会比数组的长度值大,因此也就不会发生数组越界.</p>
<p>(2)保证元素尽可能的均匀分布</p>
<p>在操作的时候,链表中的元素越多,效率越低,因为要不停的对链表循环比较.所以,一定要使哈希均匀分布,尽量减少哈希冲突,提高效率。</p>
<p><strong>n</strong> <em><strong>*继续存入数据*</strong></em></p>
<p>继续存入数据,还是要通过第1步计算key在数组中的索引位置. 如果当前位置存在元素的话,再通过key的equal()方法判断key是否相同,如果相同value值就会覆盖; 如果key的equals()方法不同,则在数组对应索引位置变为链表存储新的Entry&lt;key,value&gt;。</p>
<p><strong>n</strong> <em><strong>*拉链法*</strong></em></p>
<p>上一步说到的链表是拉链法: 将链表和数组相结合.也就是说创建一个链表数组,数组中每一格就是一个链表.若约到哈希冲突,则将冲突的值加到链表中即可.</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88D0.tmp.jpg" alt="img"> </p>
<p><strong>l</strong> <em><strong>*JDK1.8之后(数组+链表+红黑树)*</strong></em></p>
<p>如果链表的长度超过8则转为红黑树, 当红黑树中的元素小于6时又变为链表(有这些变化的原因就是综合时间复杂度以及空间复杂度的考虑)获取时,直接找到key的hash值对应的下标,在进一步用equels方法判断key是否相同,从而找到对应值则返回找不到则返回null。</p>
<p>相比于之前的版本,jdk1.8在解决哈希冲突时有了较大的变化,当链表长度大于阀值(默认为8)时,将链表转化为红黑树,以减少搜索时间。</p>
<p>​    <img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88D1.tmp.jpg" alt="img"></p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88D2.tmp.jpg" alt="img"> </p>
<h3 id="1-17谈一下-hashMap-中什么时候需要进行扩容，扩容-resize-又是如何实现的？-高薪常问"><a href="#1-17谈一下-hashMap-中什么时候需要进行扩容，扩容-resize-又是如何实现的？-高薪常问" class="headerlink" title="1.17谈一下 hashMap 中什么时候需要进行扩容，扩容 resize()又是如何实现的？(高薪常问)"></a>1.17谈一下 hashMap 中什么时候需要进行扩容，扩容 resize()又是如何实现的？(高薪常问)</h3><p><em><strong>*调用场景：*</strong></em> </p>
<p>\1. 初始化数组 table </p>
<p>\2. 当数组 table 的 size 达到阙值时进行扩容 </p>
<p><em><strong>*实现过程：*</strong></em> </p>
<p>通过判断旧数组的容量是否大于0来判断数组是否初始化过。</p>
<p>l 如果小于0：进行初始化,判断是否调用无参构造器。</p>
<p>如果调用了无参构造器: 使用默认的大小和阙值&lt;阈值 12. 阀值=默认    大小为16乘以负载因子0.75。</p>
<p>如果没有调用无参构造器: 使用构造函数中初始化的容量, 当然这个容    量是经过tableSizefor 计算后的 2 的次幂数) 。</p>
<p>l 如果大于0: 进行扩容，扩容成两倍(小于最大值的情况下)，之后在进行将元素重新进行与运算复制到新的散列表中。</p>
<p><em><strong>*概括的讲：*</strong></em></p>
<p>扩容需要重新分配一个新数组，新数组是老数组的2倍长，然后遍历整个老结<strong>构，</strong>把所有的元素挨个重新hash分配到新结构中去。PS：可见底层数据结构用到了数组，到最后会因为容量问题都需要进行扩容操作。</p>
<h3 id="ConcurrentHashMap特点-高薪常问"><a href="#ConcurrentHashMap特点-高薪常问" class="headerlink" title="ConcurrentHashMap特点(高薪常问)"></a>ConcurrentHashMap特点(高薪常问)</h3><p><strong>Segment 段</strong> </p>
<p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分”或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个segment。  </p>
<p><strong>线程安全（Segment 继承 ReentrantLock 加锁）</strong> </p>
<p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个Segment 是线程安全的，也就实现了全局的线程安全。</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88D3.tmp.jpg" alt="img"> </p>
<p><strong>并行度（默认 16）</strong> </p>
<p>concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。 </p>
<p><strong>Java8 实现 （引入了红黑树）</strong> </p>
<p>Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88D4.tmp.jpg" alt="img"> </p>
<h3 id="HashTable-了解"><a href="#HashTable-了解" class="headerlink" title="HashTable(了解)"></a>HashTable(了解)</h3><p>Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。</p>
<h3 id="HashMap-和-HashTable-有什么区别-必会"><a href="#HashMap-和-HashTable-有什么区别-必会" class="headerlink" title="HashMap 和 HashTable 有什么区别?(必会)"></a>HashMap 和 HashTable 有什么区别?(必会)</h3><p>HashMap 是线程不安全的,是 Map 的一个实现类,是将键映射到值得对象,不允许键值重复,允许空键和空值;由于非线程安全,HashMap 的效率要较 HashTable 的效率高一些. </p>
<p>HashTable 是线程安全的一个集合,不允许 null 值作为一个 key 值或者 Value 值; </p>
<p>HashTable 是 sychronize,多个线程访问时不需要自己为它的方法实现同步,而 HashMap 在被多个线程访问的时候需要自己为它的方法实现同步;</p>
<h3 id="HashMap，HashTable，ConcurrentHashMap之间的区别，及性能对比-必会"><a href="#HashMap，HashTable，ConcurrentHashMap之间的区别，及性能对比-必会" class="headerlink" title="HashMap，HashTable，ConcurrentHashMap之间的区别，及性能对比(必会)"></a>HashMap，HashTable，ConcurrentHashMap之间的区别，及性能对比(必会)</h3><p><em><strong>*性能：*<em><strong>ConcurrentHashMap(</strong></em>*线程安全*</strong></em>) &gt; HashMap &gt; HashTable(<em><strong>*线程安全*</strong></em>)</p>
<p><em><strong>*区别对比一(HashMap和HashTable区别)：*</strong></em></p>
<p>1、HashMap是非线程安全的，HashTable是线程安全的。</p>
<p>2、HashMap的键和值都允许有null值存在，而HashTable则不行。</p>
<p>3、因为线程安全的问题，HashMap效率比HashTable的要高。</p>
<p>4、Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。一般现在不建议用HashTable, ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。</p>
<p><em><strong>*区别对比二(HashTable和ConcurrentHashMap区别)：*</strong></em></p>
<p>****HashTable*<em><strong>使用的是Synchronized关键字修饰，</strong></em>*ConcurrentHashMap****是使用了锁分段技术来保证线程安全的。</p>
<p>****Hashtable*<em><strong>中采用的锁机制是一次锁住整个hash表，从而在同一时刻只能由一个线程对其进行操作；而</strong></em>*ConcurrentHashMap****中则是一次锁住一个桶。</p>
<p>ConcurrentHashMap默认将hash表分为16个桶，诸如get、put、remove等常用操作只锁住当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有16个写线程执行，并发性能的提升是显而易见的。</p>
<h3 id="什么是线程-线程和进程的区别-必会"><a href="#什么是线程-线程和进程的区别-必会" class="headerlink" title="什么是线程?线程和进程的区别?(必会)"></a>什么是线程?线程和进程的区别?(必会)</h3><p>****线程：****是进程的一个实体，是 cpu 调度和分派的基本单位，是比进程更小的可以独立运行的基本单位。</p>
<p>****进程：****具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位。 </p>
<p>****特点：****线程的划分尺度小于进程，这使多线程程序拥有高并发性，进程在运行时各自内存单元相互独立，线程之间 内存共享，这使多线程编程可以拥有更好的性能和用户体验。</p>
<p>****注意****：多线程编程对于其它程序是不友好的，占据大量 cpu 资源。 </p>
<h3 id="创建线程有几种方式-必会"><a href="#创建线程有几种方式-必会" class="headerlink" title="创建线程有几种方式(必会)"></a>创建线程有几种方式(必会)</h3><p><em><strong>*1.继承 Thread 类*</strong></em> </p>
<p>Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start()实例方法。****start()方法是一个 native 方法****，它将启动一个新线程，并执行 run()方法。</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88D5.tmp.jpg" alt="img"> </p>
<p><em><strong>*2.实现Runnable接口*</strong></em></p>
<p>如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现</p>
<p>一个 Runnable 接口。 </p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88D6.tmp.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88D7.tmp.jpg" alt="img"> </p>
<p><em><strong>*3.实现Callable接口*</strong></em></p>
<p>Callabled接口有点儿像是Runnable接口的增强版，它****以call()方法作为线程执行体****，    call()方法比run()方法功能更强大。</p>
<p>****call()方法可以有返回值，可以声明抛出异常类****。</p>
<p>获取call()方法里的返回值: 通过FutureTask类（实现Future接口）的实例对象的get()方法得到，得到结果类型与创建TutureTask类给的泛型一致。</p>
<p><em><strong>*具体代码实现*</strong></em></p>
<p><em><strong>*1*</strong></em><em><strong>*.*</strong></em><em><strong>*定义实现Callable接口的实现类，并实现call()方法。注意：Callable有泛型限制，与返回值类型一致。这里是Integer*</strong></em></p>
<p>public class ThirdThread implements Callable<Integer>{//重写call()方法}</p>
<p><em><strong>*2*</strong></em><em><strong>*.*</strong></em><em><strong>*再创建Callable实现类的实例tt。*</strong></em></p>
<p>ThirdThread tt = new ThirdThread();</p>
<p><em><strong>*3.*</strong></em><em><strong>*使用FutureTask类包装Callable的实例tt。*</strong></em></p>
<p>FutureTask<Integer> task = new FutureTask<Integer>(tt);//注意：泛型限制与返回结果一致。</p>
<p><em><strong>*4.以FutureTask对象（task）作为Thread的target来创建线程，并启动。*</strong></em></p>
<p>new Thread(task, “线程”).start();</p>
<p><em><strong>*5.调用FutureTask对象（task）的get()方法获得返回值*</strong></em></p>
<p>Integer result = task.get();//会有异常</p>
<p><strong>4.</strong> <em><strong>*通过线程池方法*</strong></em></p>
<p>l 什么是线程池,如何使用?</p>
<p>线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用 new 线程而是直接去池中拿线程即可，节省了开辟子线程的时间，提高的代码执行效率。</p>
<p>在 JDK 的 java.util.concurrent.Executors 中提供了生成多种线程池的静态方法.</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88D8.tmp.jpg" alt="img"> </p>
<p>然后调用他们的 execute 方法即可。</p>
<p><em><strong>*合理利用线程池能够带来三个好处。*</strong></em> </p>
<p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 </p>
<p>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
<p>第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控. </p>
<p>l 常用的线程池有哪些？</p>
<p>****newSingleThreadExecutor：****创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 </p>
<p>****newFixedThreadPool：****创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。 </p>
<p>****newCachedThreadPool：****创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。 </p>
<p>****newScheduledThreadPool：****创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。 </p>
<h3 id="线程的基本方法有什么-必会"><a href="#线程的基本方法有什么-必会" class="headerlink" title="线程的基本方法有什么?(必会)"></a>线程的基本方法有什么?(必会)</h3><p>线程相关的基本方法有 <em><strong>*wait，notify，notifyAll，sleep，join，yield*</strong></em> 等。</p>
<p><em><strong>*1.线程等待（wait）*</strong></em> </p>
<p>调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用 wait()方法后，****会释放对象的锁****。因此，wait 方法一般用在同步方法或同步代码块中。 </p>
<p><em><strong>*2.线程睡眠（sleep）*</strong></em> </p>
<p><em><strong>*sleep 导致当前线程休眠，与 wait 方法不同的是*</strong></em> <em><strong>*sleep 不会释放当前占有的锁*</strong></em><em><strong>*,sleep(long)会导致线程进入*</strong></em> <em><strong>*TIMED-WATING*</strong></em> <em><strong>*状态，而*</strong></em> <em><strong>*wait()方法会导致当前线程进入 WATING*</strong></em> <em><strong>*状态.*</strong></em></p>
<p><em><strong>*3.线程让步（yield）*</strong></em> </p>
<p>yield 会使当前线程****让出 CPU 执行时间片****，与其他线程一起重新竞争 CPU 时间片。一般情况下， 优先级高的线程有更大的可能性成功竞争得到 CPU 时间片，但这又不是绝对的，有的操作系统对 线程优先级并不敏感。</p>
<p><em><strong>*4.线程中断（interrupt）*</strong></em> </p>
<p>中断一个线程，其本意是<em><strong>*给这个线程一个通知信号，会影响这个线程内部的一个中断标识位*</strong></em><em><strong>*。*</strong></em><em><strong>*这个线程本身并不会因此而改变状态(如阻塞，终止等)*</strong></em></p>
<p><em><strong>*5.Join 等待其他线程终止*</strong></em> </p>
<p>****join() 方法，等待其他线程终止****，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸.</p>
<p><em><strong>*6.线程唤醒（notify）*</strong></em> </p>
<p>Object 类中的 notify() 方法，****唤醒在此对象监视器上等待的单个线程*<em><strong>，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个 wait() 方法，在对象的监视器上等待，</strong></em>*直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程****，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程。</p>
<h3 id="在-java-中-wait-和-sleep-方法的不同？-必会"><a href="#在-java-中-wait-和-sleep-方法的不同？-必会" class="headerlink" title="在 java 中 wait 和 sleep 方法的不同？(必会)"></a>在 java 中 wait 和 sleep 方法的不同？(必会)</h3><p>最大的不同是在等待时 wait 会释放锁，而 sleep 一直持有锁。wait 通常被用于线程间交互，sleep 通常被用于暂停执行。 </p>
<h3 id="线程池原理-高薪常问"><a href="#线程池原理-高薪常问" class="headerlink" title="线程池原理(高薪常问)"></a>线程池原理(高薪常问)</h3><p>线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量<em><strong>*超出数量的线程排队等候*<em><strong>，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：</strong></em>*线程复用；控制最大并发数；管理线程*</strong></em><em><strong>*。*</strong></em> </p>
<p><em><strong>*线程复用:*</strong></em></p>
<p>每一个 Thread 的类都有一个 start 方法。 当调用 start 启动线程时 Java 虚拟机会调用该类的 run 方法。 那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。 ****我们可以继承重写 Thread 类，在其 start 方法中添加不断循环调用传递过来的 Runnable 对象*<em><strong>。 这就是线程池的实现原理。</strong></em>*循环方法中不断获取 Runnable 是用 Queue 实现的****，在获取下一个 Runnable 之前可以是阻塞的。</p>
<p><em><strong>*线程池的组成:*</strong></em></p>
<p>一般的线程池主要分为以下 4 个组成部分：</p>
<p>\1. 线程池管理器：用于创建并管理线程池 </p>
<p>\2. 工作线程：线程池中的线程 </p>
<p>\3. 任务接口：每个任务必须实现的接口，用于工作线程调度其运行 </p>
<p>\4. 任务队列：用于存放待处理的任务，提供一种缓冲机制</p>
<p><em><strong>*拒绝策略:*</strong></em> </p>
<p>线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。 </p>
<p>JDK 内置的拒绝策略如下： </p>
<p>\1. AbortPolicy ： 直接抛出异常，阻止系统正常运行。 </p>
<p>\2. CallerRunsPolicy ： 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。 </p>
<p>\3. DiscardOldestPolicy ： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。 </p>
<p>\4. DiscardPolicy ： 该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案</p>
<p><em><strong>*Java 线程池工作过程:*</strong></em> </p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88E8.tmp.jpg" alt="img"> </p>
<p>\1. 线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。 </p>
<p>\2. 当调用 execute() 方法添加一个任务时，线程池会做如下判断： </p>
<p>a) 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务； </p>
<p>b) 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列； </p>
<p>c) 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务； </p>
<p>d) 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常 RejectExecutionException。 </p>
<p>\3. 当一个线程完成任务时，它会从队列中取下一个任务来执行。 </p>
<p>\4. 当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p>
<h3 id="线程执行的顺序-高薪常问"><a href="#线程执行的顺序-高薪常问" class="headerlink" title="线程执行的顺序(高薪常问)"></a>线程执行的顺序(高薪常问)</h3><p>\1. 当线程数小于核心线程数时，会一直创建线程直到线程数等于核心线程数；</p>
<p>\2. 当线程数等于核心线程数时，新加入的任务会被放到任务队列等待执行；</p>
<p>\3. 当任务队列已满，又有新的任务时，会创建线程直到线程数量等于最大线程数；</p>
<p>\4. 当线程数等于最大线程数，且任务队列已满时，新加入任务会被拒绝。</p>
<h3 id="线程池的核心参数有哪些？-高薪常问"><a href="#线程池的核心参数有哪些？-高薪常问" class="headerlink" title="线程池的核心参数有哪些？(高薪常问)"></a>线程池的核心参数有哪些？(高薪常问)</h3><p><em><strong>*默认参数：*</strong></em></p>
<p>corePoolSize = 1</p>
<p>queueCapacity = Integer.MAX_VALUE</p>
<p>maxPoolSize = Integer.MAX_VALUE</p>
<p>keepAliveTime = 60秒</p>
<p>allowCoreThreadTimeout = false</p>
<p>rejectedExecutionHandler = AbortPolicy()</p>
<p><em><strong>*具体讲解：*</strong></em></p>
<p><em><strong>*1.corePoolSize（核心线程数）*</strong></em></p>
<p>（1）核心线程会一直存在，即使没有任务执行；</p>
<p>（2）当线程数小于核心线程数的时候，即使有空闲线程，也会一直创建线程直到达到核心线程数；</p>
<p>（3）设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭。</p>
<p><em><strong>*2.queueCapacity（任务队列容量）*</strong></em></p>
<p>也叫阻塞队列，当核心线程都在运行，此时再有任务进来，会进入任务队列，排队等待线程执行。</p>
<p><em><strong>*3.maxPoolSize（最大线程数）*</strong></em></p>
<p>（1）线程池里允许存在的最大线程数量；</p>
<p>（2）当任务队列已满，且线程数量大于等于核心线程数时，会创建新的线程执行任务；</p>
<p>（3）线程池里允许存在的最大线程数量。当任务队列已满，且线程数量大于等于核心线程数时，会创建新的线程执行任务。</p>
<p><em><strong>*4.keepAliveTime（线程空闲时间）*</strong></em></p>
<p>（1）当线程空闲时间达到keepAliveTime时，线程会退出（关闭），直到线程数等于核心线程数；</p>
<p>（2）如果设置了allowCoreThreadTimeout=true，则线程会退出直到线程数等于零。&lt;allowCoreThreadTimeout（允许核心线程超时）&gt;</p>
<p>当线程数量达到最大线程数，且任务队列已满时，会拒绝任务；</p>
<p>调用线程池shutdown()方法后，会等待执行完线程池的任务之后，再shutdown()。如果在调用了shutdown()方法和线程池真正shutdown()之间提交任务，会拒绝新任务。</p>
<h3 id="死锁产生的条件以及如何避免？-高薪常问"><a href="#死锁产生的条件以及如何避免？-高薪常问" class="headerlink" title="死锁产生的条件以及如何避免？(高薪常问)"></a>死锁产生的条件以及如何避免？(高薪常问)</h3><p><em><strong>*死锁产生的四个必要条件：*</strong></em></p>
<p>互斥：一个资源每次只能被一个进程使用（资源独立）。</p>
<p>请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放（不释放锁）。</p>
<p>不剥夺：进程已获得的资源，在未使用之前，不能强行剥夺（抢夺资源）。</p>
<p>循环等待：若干进程之间形成一种头尾相接的循环等待的资源关闭（死循环）。</p>
<p><em><strong>*避免死锁：*</strong></em></p>
<p>\1. 破坏”互斥”条件：系统里取消互斥、若资源一般不被一个进程独占使用，那么死锁是肯定不会发生的，但一般“互斥”条件是无法破坏的,因此，在死锁预防里主要是破坏其他三个必要条件，而不去涉及破坏“互斥”条件。</p>
<p>\2. 破坏“请求和保持”条件：</p>
<p>方法1：所有的进程在开始运行之前，必须一次性的申请其在整个运行过程各种所需要的全部资源。</p>
<p>优点：简单易实施且安全。</p>
<p>缺点：因为某项资源不满足，进程无法启动，而其他已经满足了的资源也不会得到利用，严重降低了资源的利用率，造成资源浪费。</p>
<p>方法2：该方法是对第一种方法的改进，允许进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到，已经使用完毕的资源，然后再去请求新的资源。这样的话资源的利用率会得到提高，也会减少进程的饥饿问题。</p>
<p>\3. 破坏“不剥夺”条件：当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。这就意味着进程已占有的资源会被短暂的释放或者说被抢占了。</p>
<p>\4. 破坏“循环等待”条件：可以通过定义资源类型的线性顺序来预防，可以将每个资源编号，当一个进程占有编号为i的资源时，那么它下一次申请资源只能申请编号大于i的资源。</p>
<h3 id="JVM是什么？JVM的基本结构-高薪常问"><a href="#JVM是什么？JVM的基本结构-高薪常问" class="headerlink" title="JVM是什么？JVM的基本结构 (高薪常问)"></a>JVM是什么？JVM的基本结构 (高薪常问)</h3><p>虚拟机，一种能够运行java字节码的虚拟机。</p>
<p>l 类加载子系统</p>
<p>l 加载 .class 文件到内存。</p>
<p>l 内存结构</p>
<p>l 运行时的数据区。</p>
<p>l 执行引擎</p>
<p>l 执行内存中的.class，输出执行结果（包含GC：垃圾收集器）。</p>
<p>l 本地方法的接口。</p>
<p>l 本地方法库。</p>
<p>​        <img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88E9.tmp.jpg" alt="img"></p>
<h3 id="JVM内存结构-高薪常问"><a href="#JVM内存结构-高薪常问" class="headerlink" title="JVM内存结构(高薪常问)"></a>JVM内存结构(高薪常问)</h3><p><em><strong>*JDK1.7*</strong></em></p>
<p>​            <img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88EA.tmp.jpg" alt="img"></p>
<p><em><strong>*程序计数器*</strong></em></p>
<p>就是一个指针，指向方法区中的方法字节码（用来存储指向下一个指令的地址，也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计。</p>
<p><em><strong>*Java虚拟机栈*</strong></em></p>
<p>Java线程执行方法的内存模型，一个线程对应一个栈，每个方法在执行的同时都会创建一个栈帧（用于存储局部变量表，操作数栈，动态链接，方法出口等信息）不存在垃圾回收问题，只要线程一结束该栈就释放，生命周期和线程一致。</p>
<p><em><strong>*本地方法栈*</strong></em></p>
<p>和栈作用很相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行native方法服务。登记native方法，在Execution Engine执行时加载本地方法库。</p>
<p><em><strong>*堆*</strong></em></p>
<p>Java虚拟机管理的最大的一块内存区域，Java堆是线程共享的，用于存放对象实例。也就是说对象的出生和回收都是在这个区域进行的。</p>
<p><em><strong>*方法区*</strong></em></p>
<p>线程共享，用于存储已经被虚拟机加载的类信息、常量、静态变量等数据。</p>
<p><em><strong>*JDK1.8*</strong></em></p>
<p>​            <img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88EB.tmp.jpg" alt="img"></p>
<p>JDK1.8与1.7最大的区别是在1.8中方法区是由元空间（元数据区）来实现。常量池移到堆中。</p>
<h3 id="类的加载，类加载器的种类-类加载机制-高薪常问"><a href="#类的加载，类加载器的种类-类加载机制-高薪常问" class="headerlink" title="类的加载，类加载器的种类,类加载机制(高薪常问)"></a>类的加载，类加载器的种类,类加载机制(高薪常问)</h3><p><strong>l</strong> <em><strong>*类加载*</strong></em></p>
<p>​    <img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88EC.tmp.jpg" alt="img"></p>
<p>1.加载</p>
<p>将.class文件从磁盘读到内存。</p>
<p>2.连接</p>
<p>2.1 验证: 验证字节码文件的正确性。</p>
<p>2.2 准备: 给类的静态变量分配内存，并赋予默认值。</p>
<p>2.3 解析: 类装载器装入类所引用的其它所有类。</p>
<p>3.初始化</p>
<p>为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序编写者为变量分配的真正的初始值，执行静态代码块。</p>
<p>4.使用</p>
<p>5.卸载</p>
<p><strong>l</strong> <em><strong>*类加载器的种类*</strong></em></p>
<p>\1. 启动类加载器(Bootstrap ClassLoader)</p>
<p>负责加载JRE的核心类库，如JRE目标下的rt.jar，charsets.jar等。</p>
<p>\2. 扩展类加载器(Extension ClassLoader)</p>
<p>负责加载JRE扩展目录ext中jar类包。</p>
<p>\3. 系统类加载器(Application ClassLoader)</p>
<p>负责加载ClassPath路径下的类包。</p>
<p>\4. 用户自定义加载器(User ClassLoader)</p>
<p>负责加载用户自定义路径下的类包。</p>
<p><strong>l</strong> <em><strong>*类加载机制*</strong></em></p>
<p>全盘负责委托机制</p>
<p>当A类中引用B类，那么除非特别指定B类的类加载器，否则就直接使用加载A类的类加载器加载B类。</p>
<p>双亲委派机制</p>
<p>指先委托父类加载器寻找目标类，在找不到的情况下再在自己的路径中查找并载入目标类。</p>
<h3 id="什么是GC-高薪常问"><a href="#什么是GC-高薪常问" class="headerlink" title="什么是GC(高薪常问)"></a>什么是GC(高薪常问)</h3><p>内存空间是有限的，那么在程序运行时如何及时的把不再使用的对象清除将内存释放出来，这就是GC要做的事。</p>
<p>l GC的区域在哪里？</p>
<p>JVM中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理。因此，我们的内存垃圾回收主要集中于 Java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的。</p>
<p>l GC的操作对象是什么？</p>
<p>需要进行回收的对象就是已经没有存活的对象，判断一个对象是否存活常用的有两种办法：引用计数和可达分析。</p>
<p>n 引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</p>
<p>n 可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p>
<p>在Java语言中，GC Roots包括：</p>
<p>n 虚拟机栈中引用的对象。</p>
<p>n 方法区中类静态属性实体引用的对象。</p>
<p>n 方法区中常量引用的对象。</p>
<p>n 本地方法栈中JNI引用的对象。</p>
<p>l GC的时机是什么？</p>
<p>(1)程序调用System.gc时可以触发。</p>
<p>(2)系统自身来决定GC触发的时机（根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程）。</p>
<p>l GC做了哪些事？</p>
<p>主要做了清理对象，整理内存的工作。</p>
<p>l GC常用算法</p>
<p>GC常用算法有：标记-清除算法，标记-压缩算法，复制算法，分代收集算法。目前主流的JVM（HotSpot）采用的是分代收集算法。</p>
<p><em><strong>*标记-清除算法*</strong></em></p>
<p>为每个对象存储一个标记位，记录对象的状态（活着或是死亡）。分为两个阶段，一个是标记阶段，这个阶段内，为每个对象更新标记位，检查对象是否死亡；第二个阶段是清除阶段，该阶段对死亡的对象进行清除，执行 GC 操作。</p>
<p><em><strong>*标记-压缩算法（标记-整理）*</strong></em></p>
<p>标记-压缩法是标记-清除法的一个改进版。同样，在标记阶段，该算法也将所有对象标记为存活和死亡两种状态；不同的是，在第二个阶段，该算法并没有直接对死亡的对象进行清理，而是将所有存活的对象整理一下，放到另一处空间，然后把剩下的所有对象全部清除。这样就达到了标记-整理的目的。</p>
<p><em><strong>*复制算法*</strong></em></p>
<p>该算法将内存平均分成两部分，然后每次只使用其中的一部分，当这部分内存满的时候，将内存中所有存活的对象复制到另一个内存中，然后将之前的内存清空，只使用这部分内存，循环下去。</p>
<p><em><strong>*分代收集算法*</strong></em></p>
<p>现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代(Young)和老年代(Tenure)。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。</p>
<h3 id="JVM调优的工具有哪些？-高薪常问"><a href="#JVM调优的工具有哪些？-高薪常问" class="headerlink" title="JVM调优的工具有哪些？(高薪常问)"></a>JVM调优的工具有哪些？(高薪常问)</h3><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>
<p>\1. jconsole：用于对 JVM 中的内存、线程和类等进行监控；</p>
<p>\2. jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</p>
<h3 id="常用的-JVM-调优的参数都有哪些？-高薪常问"><a href="#常用的-JVM-调优的参数都有哪些？-高薪常问" class="headerlink" title="常用的 JVM 调优的参数都有哪些？(高薪常问)"></a>常用的 JVM 调优的参数都有哪些？(高薪常问)</h3><p>XX比X的稳定性更差，并且版本更新不会进行通知和说明。</p>
<p>-Xms：s为strating，表示堆内存起始大小。</p>
<p>-Xmx：x为max，表示最大的堆内存（一般来说-Xms和-Xmx的设置为相同大小，因为当heap自动扩容时，会发生内存抖动，影响程序的稳定性）。</p>
<p>-Xmn：n为new，表示新生代大小（-Xss：规定了每个线程虚拟机栈（堆栈）的大小）。</p>
<p>-XX:SurvivorRator=8 表示堆内存中新生代、老年代和永久代的比为8:1:1。</p>
<p>-XX:PretenureSizeThreshold=3145728表示当创建（new）的对象大于3M的时候直接进入。</p>
<p>-XX:MaxTenuringThreshold=15表示当对象的存活的年龄（minor gc一次加1）大于多少时，进入老年代。</p>
<p>-XX:-DisableExplicirGC表示是否（+表示是，-表示否）打开GC日志。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sixwudou.github.io/2022/01/23/2034/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.gif">
      <meta itemprop="name" content="毋  豆">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="毋  豆 Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/23/2034/" class="post-title-link" itemprop="url">2034</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-23 19:31:19" itemprop="dateCreated datePublished" datetime="2022-01-23T19:31:19+08:00">2022-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-24 15:43:59" itemprop="dateModified" datetime="2022-01-24T15:43:59+08:00">2022-01-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="2034-股票价格波动"><a href="#2034-股票价格波动" class="headerlink" title="2034. 股票价格波动"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/stock-price-fluctuation/">2034. 股票价格波动</a></h2><h3 id="做题发现对TreeMap的知识缺乏，该页面是Tree-Map的基本方法Java-TreeMap-Java教程-菜鸟教程-cainiaojc-com"><a href="#做题发现对TreeMap的知识缺乏，该页面是Tree-Map的基本方法Java-TreeMap-Java教程-菜鸟教程-cainiaojc-com" class="headerlink" title="做题发现对TreeMap的知识缺乏，该页面是Tree Map的基本方法Java TreeMap - Java教程 - 菜鸟教程 (cainiaojc.com)"></a>做题发现对TreeMap的知识缺乏，该页面是Tree Map的基本方法<a target="_blank" rel="noopener" href="https://www.cainiaojc.com/java/java-treemap.html">Java TreeMap - Java教程 - 菜鸟教程 (cainiaojc.com)</a></h3><p>给你一支股票价格的数据流。数据流中每一条记录包含一个 <strong>时间戳</strong> 和该时间点股票对应的 <strong>价格</strong> 。</p>
<p>​        不巧的是，由于股票市场内在的波动性，股票价格记录可能不是按时间顺序到来的。某些情况下，有的记录可能是错的。如果两个有相同时间戳的记录出现在数据流中，前一条记录视为错误记录，后出现的记录 <strong>更正</strong> 前一条错误的记录。</p>
<p>请你设计一个算法，实现：</p>
<ul>
<li><strong>更新</strong> 股票在某一时间戳的股票价格，如果有之前同一时间戳的价格，这一操作将 <strong>更正</strong> 之前的错误价格。</li>
<li>找到当前记录里 <strong>最新股票价格</strong> 。<strong>最新股票价格</strong> 定义为时间戳最晚的股票价格。</li>
<li>找到当前记录里股票的 <strong>最高价格</strong> 。</li>
<li>找到当前记录里股票的 <strong>最低价格</strong> 。</li>
</ul>
<p>请你实现 <code>StockPrice</code> 类：</p>
<ul>
<li><code>StockPrice()</code> 初始化对象，当前无股票价格记录。</li>
<li><code>void update(int timestamp, int price)</code> 在时间点 <code>timestamp</code> 更新股票价格为 <code>price</code> 。</li>
<li><code>int current()</code> 返回股票 <strong>最新价格</strong> 。</li>
<li><code>int maximum()</code> 返回股票 <strong>最高价格</strong> 。</li>
<li><code>int minimum()</code> 返回股票 <strong>最低价格</strong> 。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;StockPrice&quot;, &quot;update&quot;, &quot;update&quot;, &quot;current&quot;, &quot;maximum&quot;, &quot;update&quot;, &quot;maximum&quot;, &quot;update&quot;, &quot;minimum&quot;]</span><br><span class="line">[[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 5, 10, null, 5, null, 2]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">StockPrice stockPrice = new StockPrice();</span><br><span class="line">stockPrice.update(1, 10); // 时间戳为 [1] ，对应的股票价格为 [10] 。</span><br><span class="line">stockPrice.update(2, 5);  // 时间戳为 [1,2] ，对应的股票价格为 [10,5] 。</span><br><span class="line">stockPrice.current();     // 返回 5 ，最新时间戳为 2 ，对应价格为 5 。</span><br><span class="line">stockPrice.maximum();     // 返回 10 ，最高价格的时间戳为 1 ，价格为 10 。</span><br><span class="line">stockPrice.update(1, 3);  // 之前时间戳为 1 的价格错误，价格更新为 3 。</span><br><span class="line">                          // 时间戳为 [1,2] ，对应股票价格为 [3,5] 。</span><br><span class="line">stockPrice.maximum();     // 返回 5 ，更正后最高价格为 5 。</span><br><span class="line">stockPrice.update(4, 2);  // 时间戳为 [1,2,4] ，对应价格为 [3,5,2] 。</span><br><span class="line">stockPrice.minimum();     // 返回 2 ，最低价格时间戳为 4 ，价格为 2 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= timestamp, price &lt;= 109</code></li>
<li><code>update</code>，<code>current</code>，<code>maximum</code> 和 <code>minimum</code> <strong>总</strong> 调用次数不超过 <code>105</code> 。</li>
<li><code>current</code>，<code>maximum</code> 和 <code>minimum</code> 被调用时，<code>update</code> 操作 <strong>至少</strong> 已经被调用过 <strong>一次</strong> 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">模拟 + 数据结构</span><br><span class="line">容易想到我们需要使用「哈希表」来记录 &#123;时间:价格&#125; 的映射关系。</span><br><span class="line"></span><br><span class="line">关于 current 操作，我们可以维护一个最大的时间戳 cur，在调用 current 的时候直接 O(<span class="number">1</span>)O(<span class="number">1</span>) 查得结果。</span><br><span class="line"></span><br><span class="line">然后考虑解决 update 操作中对相同时间点的更新问题，我们可以使用 TreeMap（红黑树）来解决该问题。以 &#123;价格:该价格对应的时间点数量&#125; 的 KV 形式进行存储，key 按照「升序」进行排序。</span><br><span class="line"></span><br><span class="line">然后对传入的 timestamp 是否已经被记录（是否已经存在哈希表中）进行分情况讨论：</span><br><span class="line"></span><br><span class="line">传入的 timestamp 未被记录，直接更新哈希表和 TreeMap；</span><br><span class="line">传入的 timestamp 已被记录，此时需要先从哈希表取出旧价格 old，然后用旧价格对 TreeMap 进行修改（如果该价格只有一个时间点，将该价格直接从 TreeMap 中移除；若有多个时间点，则对该价格对应的时间点数量进行减一操作），然后再使用传入的新价格 price 更新哈希表和 TreeMap。</span><br><span class="line">minimum 和 maximum 操作则只需要取得 TreeMap 的首尾 Key 即可。</span><br><span class="line"></span><br><span class="line">作者：AC_OIer</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/stock-price-fluctuation/solution/gong-shui-san-xie-shu-ju-jie-gou-mo-ni-t-u6f4/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockPrice</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur ;<span class="comment">//记录最新时间戳</span></span><br><span class="line">    Map&lt;Integer,Integer&gt; map;</span><br><span class="line">    TreeMap&lt;Integer,Integer&gt; tm;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StockPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        tm = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> timestamp, <span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        cur = Math.max(cur,timestamp);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(timestamp))&#123;</span><br><span class="line">            <span class="keyword">int</span> old = map.get(timestamp);</span><br><span class="line">            <span class="keyword">int</span> cnt = tm.get(old);</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">1</span>) tm.remove(old);</span><br><span class="line">            <span class="keyword">else</span> tm.put(old,cnt-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        map.put(timestamp,price);</span><br><span class="line">        tm.put(price, tm.getOrDefault(price, <span class="number">0</span>) + <span class="number">1</span>);<span class="comment">//getOrDefault(key,iNum) 方法获取指定 key 对应的 value，如果找不到 key ，则返回设置的默认值iNum。</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(cur);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tm.lastKey();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tm.firstKey();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StockPrice object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StockPrice obj = new StockPrice();</span></span><br><span class="line"><span class="comment"> * obj.update(timestamp,price);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.current();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.maximum();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.minimum();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sixwudou.github.io/2022/01/23/MyBatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.gif">
      <meta itemprop="name" content="毋  豆">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="毋  豆 Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/23/MyBatis/" class="post-title-link" itemprop="url">MyBatis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-23 14:35:38" itemprop="dateCreated datePublished" datetime="2022-01-23T14:35:38+08:00">2022-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-12 16:15:11" itemprop="dateModified" datetime="2022-02-12T16:15:11+08:00">2022-02-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是-MyBatis？"><a href="#什么是-MyBatis？" class="headerlink" title="什么是 MyBatis？"></a>什么是 MyBatis？</h2><p><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/getting-started.html">mybatis – MyBatis 3 | 入门</a></p>
<p>​        MyBatis 是一款优秀的<strong>持久层框架</strong>，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录</p>
<p>Maven:<a target="_blank" rel="noopener" href="https://mvnrepository.com/">Maven Repository: Search/Browse/Explore (mvnrepository.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="MyBatis的功能架构："><a href="#MyBatis的功能架构：" class="headerlink" title="MyBatis的功能架构："></a>MyBatis的功能架构：</h2><hr>
<p>我们把Mybatis的功能架构分为三层：</p>
<ol>
<li>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</li>
<li>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</li>
<li>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</li>
</ol>
<h2 id="MyBatis的优缺点"><a href="#MyBatis的优缺点" class="headerlink" title="MyBatis的优缺点"></a>MyBatis的优缺点</h2><hr>
<p><strong>优点：</strong></p>
<ul>
<li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</li>
<li>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql基本上可以实现我们不使用数据访问框架可以实现的所有功能，或许更多。</li>
<li>解除sql与程序代码的耦合：通过提供DAL层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。</li>
<li>提供映射标签，支持对象与数据库的orm字段关系映射</li>
<li>提供对象关系映射标签，支持对象关系组建维护</li>
<li>提供xml标签，支持编写动态sql。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>编写SQL语句时工作量很大，尤其是字段多、关联表多时，更是如此。</li>
<li>SQL语句依赖于数据库，导致数据库移植性差，不能更换数据库。</li>
<li>框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。</li>
<li>二级缓存机制不佳</li>
</ul>
<h2 id="第一个Mybatis程序"><a href="#第一个Mybatis程序" class="headerlink" title="第一个Mybatis程序"></a>第一个Mybatis程序</h2><p>思路：搭建环境–&gt;导入Mybatis–&gt;编写代码–&gt;测试</p>
<h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p>搭建数据库<br>新建项目</p>
<ul>
<li><p>新建一个普通maven项目</p>
</li>
<li><p>删除src目录</p>
</li>
<li><p>导入maven依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="创建一个模块"><a href="#创建一个模块" class="headerlink" title="创建一个模块"></a>创建一个模块</h2><h3 id="mybatis-config-xml-编写mybatis的核心配置文件"><a href="#mybatis-config-xml-编写mybatis的核心配置文件" class="headerlink" title="mybatis-config.xml(编写mybatis的核心配置文件)"></a>mybatis-config.xml(编写mybatis的核心配置文件)</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>serverTimezone=GMT&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/wudou/dao/userMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="userMapper-xml-接口实现类由原来的UserDaoImpl转变成一个Mapper配置文件。"><a href="#userMapper-xml-接口实现类由原来的UserDaoImpl转变成一个Mapper配置文件。" class="headerlink" title="userMapper.xml(接口实现类由原来的UserDaoImpl转变成一个Mapper配置文件。)"></a>userMapper.xml(接口实现类由原来的UserDaoImpl转变成一个Mapper配置文件。)</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.wudou.dao.UserDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getuserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.wudou.pojo.user&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="MybatisUtils-编写mybatis工具类"><a href="#MybatisUtils-编写mybatis工具类" class="headerlink" title="MybatisUtils(编写mybatis工具类)"></a>MybatisUtils(编写mybatis工具类)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wudou.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.jdbc.SQL;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wudou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022/1/23 17:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//SqlSessionFactory --&gt; SqlSession</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取SQLSessionFactory对象</span></span><br><span class="line">            String resource =<span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory= <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。</span></span><br><span class="line">    <span class="comment">//SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlsession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name, String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPwd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPwd</span><span class="params">(String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, pwd=&#x27;&quot;</span> + pwd + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>namespace中的包名要和Dao/Mapper接口的包名一致！</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>选择，查询语句；</p>
<ul>
<li>id:就是对应的namespace中的方法名；</li>
<li>resultType:Sql语句执行的返回值！</li>
<li>parameterType:参数类型！</li>
</ul>
<h4 id="编写接口"><a href="#编写接口" class="headerlink" title="编写接口"></a>编写接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据id查询用户</span></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="编写对应的mapper中的sql语句"><a href="#编写对应的mapper中的sql语句" class="headerlink" title="编写对应的mapper中的sql语句"></a>编写对应的mapper中的sql语句</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserById</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">		UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    	User user = mapper.getUserById(<span class="number">1</span>);</span><br><span class="line">    	System.out.println(user);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//关闭SqlSession</span></span><br><span class="line">    	sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">       insert into mybatis.user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)</span><br><span class="line">   <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">       update mybatis.user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">       delete from mybatis.user where id = #&#123;id&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意点：增删改需要提交事务！</p>
<h3 id="万能Map"><a href="#万能Map" class="headerlink" title="万能Map"></a>万能Map</h3><p>假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map！</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//万能的Map</span><br><span class="line">    int addUser2(Map&lt;String,Object&gt; map);</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--对象中的属性，可以直接取出来  传递map的key--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        insert into mybatis.user (id,pwd) values (#&#123;userid&#125;,#&#123;password&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser2</span><span class="params">()</span></span>&#123;</span><br><span class="line">         SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">         UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">         Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">         map.put(<span class="string">&quot;userid&quot;</span>,<span class="number">4</span>);</span><br><span class="line">         map.put(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123321&quot;</span>);</span><br><span class="line"></span><br><span class="line">         mapper.addUser2(map);</span><br><span class="line"></span><br><span class="line">         sqlSession.commit();</span><br><span class="line">         sqlSession.close();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>Map传递参数，直接在sql中取出key即可！【parameterType=“map”】<br>对象传递参数，直接在sql中取对象的属性即可！【parameterType=“Object”】<br>只有一个基本类型参数的情况下，可以直接在sql中取到！<br>多个参数用Map，或者注解！</p>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>模糊查询怎么写？</p>
<ol>
<li><p>java代码执行的时候，传递通配符% %</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; userList = mapper.getUserLike(<span class="string">&quot;%李%&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>在sql拼接中使用通配符！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from mybatis.user where name like <span class="string">&quot;%&quot;</span>#&#123;value&#125;<span class="string">&quot;%&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h2><h3 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h3><ul>
<li>mybatis-config.xml</li>
<li>MyBatis的配置文件包含了会深深影响MyBatis行为的设置和属性信息。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">configuration（配置）</span><br><span class="line">properties（属性）</span><br><span class="line">settings（设置）</span><br><span class="line">typeAliases（类型别名）</span><br><span class="line">typeHandlers（类型处理器）</span><br><span class="line">objectFactory（对象工厂）</span><br><span class="line">plugins（插件）</span><br><span class="line">environments（环境配置）</span><br><span class="line">environment（环境变量）</span><br><span class="line">transactionManager（事务管理器）</span><br><span class="line">dataSource（数据源）</span><br><span class="line">databaseIdProvider（数据库厂商标识）</span><br><span class="line">mappers（映射器）</span><br></pre></td></tr></table></figure>

<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>Mybatis可以配置成适应多种环境。<strong>但是每个sqlSessionFactory实例只能选择一种环境</strong></p>
<p>Mybatis默认事务管理器是JDBC ,连接池：POOLED</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="使用外部java属性文件配置"><a href="#使用外部java属性文件配置" class="headerlink" title="使用外部java属性文件配置"></a>使用外部java属性文件配置</h4><h5 id="创建java属性文件——db-properties。"><a href="#创建java属性文件——db-properties。" class="headerlink" title="创建java属性文件——db.properties。"></a>创建java属性文件——db.properties。</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span> = <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span> = <span class="string">jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">username</span> = <span class="string">root</span></span><br><span class="line"><span class="attr">password</span> = <span class="string">123456</span></span><br></pre></td></tr></table></figure>

<h5 id="在mybatis-config-xml中引入这个属性文件。"><a href="#在mybatis-config-xml中引入这个属性文件。" class="headerlink" title="在mybatis-config.xml中引入这个属性文件。"></a>在mybatis-config.xml中引入这个属性文件。</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入外部配置文件        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 注册UserMapper.xml  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;cn/gbl/dao/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="在properties的子元素property-中配置"><a href="#在properties的子元素property-中配置" class="headerlink" title="在properties的子元素property 中配置"></a>在<strong>properties</strong>的子元素<strong>property</strong> 中配置</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 在properties的子元素property中配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf-8<span class="symbol">&amp;amp;</span>useSSL=true<span class="symbol">&amp;amp;</span>serverTimezone=UTC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 注册UserMapper.xml  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;cn/gbl/dao/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="也可以在-SqlSessionFactoryBuilder-build-方法中传入属性值（了解即可）"><a href="#也可以在-SqlSessionFactoryBuilder-build-方法中传入属性值（了解即可）" class="headerlink" title="也可以在 SqlSessionFactoryBuilder.build() 方法中传入属性值（了解即可）"></a>也可以在 SqlSessionFactoryBuilder.build() 方法中传入属性值（了解即可）</h5><p><strong>注意：</strong> 这三种方式如果同时存在，会有一定的优先级问题</p>
<ul>
<li>首先，读取在 properties 元素体中指定的属性；</li>
<li>其次，读取在 外部的java属性文件，且会覆盖已经指定了的重复属性；</li>
<li>最后，读取作为方法参数传递的属性，且会覆盖已经从 properties 元素体和 java外部属性文件加载了的重复属性。</li>
</ul>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">  &lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&gt;</span><br><span class="line">  &lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&gt;</span><br><span class="line">  &lt;typeAlias alias=&quot;Comment&quot; type=&quot;domain.blog.Comment&quot;/&gt;</span><br><span class="line">  &lt;typeAlias alias=&quot;Post&quot; type=&quot;domain.blog.Post&quot;/&gt;</span><br><span class="line">  &lt;typeAlias alias=&quot;Section&quot; type=&quot;domain.blog.Section&quot;/&gt;</span><br><span class="line">  &lt;typeAlias alias=&quot;Tag&quot; type=&quot;domain.blog.Tag&quot;/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure>

<p>当这样配置时，<code>Blog</code> 可以用在任何使用 <code>domain.blog.Blog</code> 的地方。</p>
<p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">  &lt;package name=&quot;domain.blog&quot;/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure>

<p>每一个在包 <code>domain.blog</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 <code>domain.blog.Author</code> 的别名为 <code>author</code>；若有注解，则别名为其注解值。见下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Alias(&quot;author&quot;)</span><br><span class="line">public class Author &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h3><p>官网中给出了很多设置，这里只介绍个别。</p>
<table>
<thead>
<tr>
<th>设置名</th>
<th>描述</th>
<th>有效值</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>logImpl</td>
<td>指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</td>
<td>SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING （这些都是日志的具体实现）</td>
<td>未设置</td>
</tr>
<tr>
<td>cacheEnabled</td>
<td>全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。</td>
<td>true | false</td>
<td>true</td>
</tr>
<tr>
<td>lazyLoadingEnabled</td>
<td>延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 <code>fetchType</code> 属性来覆盖该项的开关状态。</td>
<td>true | false</td>
<td>false</td>
</tr>
</tbody></table>
<h3 id="映射器（mappers）"><a href="#映射器（mappers）" class="headerlink" title="映射器（mappers）"></a>映射器（mappers）</h3><p>MapperRegistry：注册绑定我们的Mapper文件；<br>方式一：【推荐使用】</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--每一个Mapper.xml都需要在Mybatis核心配置文件中注册！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/kuang/dao/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>方式二：使用class文件绑定注册</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--每一个Mapper.xml都需要在Mybatis核心配置文件中注册！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li>接口和它的Mapper配置文件必须同名！</li>
<li>接口和它的Mapper配置文件必须在同一个包下!</li>
</ul>
<p>方式三：使用扫描包进行注入绑定</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--每一个Mapper.xml都需要在Mybatis核心配置文件中注册！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.kuang.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li>接口和它的Mapper配置文件必须同名！</li>
<li>接口和它的Mapper配置文件必须在同一个包下!</li>
</ul>
<h3 id="生命周期和作用域"><a href="#生命周期和作用域" class="headerlink" title="生命周期和作用域"></a>生命周期和作用域</h3><p>开始-&gt;SQLSessionFactoryBuild（配置文件启动）-&gt;SqlSessionFactor-&gt;SqlSession-&gt;Sqlmapper-&gt;结束<img src="https://img-blog.csdnimg.cn/20201023104621506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpNjQzOTM3NTc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="SQLSessionFactoryBuild"><a href="#SQLSessionFactoryBuild" class="headerlink" title="SQLSessionFactoryBuild"></a>SQLSessionFactoryBuild</h4><ul>
<li>一旦创建就不需要它</li>
<li>局部变量</li>
</ul>
<h4 id="SQLSessionFactory"><a href="#SQLSessionFactory" class="headerlink" title="SQLSessionFactory"></a>SQLSessionFactory</h4><ul>
<li>相当于数据库连接池</li>
<li>一旦被创建就应该在应用运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例</li>
</ul>
<h4 id="SQLSession"><a href="#SQLSession" class="headerlink" title="SQLSession"></a>SQLSession</h4><ul>
<li>连接到连接池得请求</li>
<li>用完之后需要赶紧关闭</li>
</ul>
<h3 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  结果集映射  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--column数据库中的字段，property实体类中的属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>resultMap 元素是 MyBatis 中最重要最强大的元素。</li>
<li>ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。</li>
<li>ResultMap 的优秀之处——你完全可以不用显式地配置它们。</li>
<li>如果这个世界总是这么简单就好了。</li>
</ul>
<h2 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h2><h3 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h3><ul>
<li>之前学过面向对象编程，也学习过接口，但在真正的开发中，很多时候会选择面向接口编程。</li>
<li><strong>根本原因</strong>：解耦，可拓展，提高复用，分层开发中，上层不用管具体的实现，大家都遵守共同的标准，使得开发变得容易，规范性更好</li>
<li>在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的，对系统设计人员来讲就不那么重要了；</li>
<li>而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。</li>
</ul>
<h3 id="使用注解开发-1"><a href="#使用注解开发-1" class="headerlink" title="使用注解开发"></a>使用注解开发</h3><ul>
<li>注解在UserMapper接口上实现，并删除UserMapper.xml文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>需要在mybatis-config.xml核心配置文件中绑定接口</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--绑定接口！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.UserMapper&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUsers</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    List&lt;User&gt; users = mapper.getUsers();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质：反射机制实现</p>
<p>底层：动态代理</p>
<h3 id="CRUD-1"><a href="#CRUD-1" class="headerlink" title="CRUD"></a>CRUD</h3><ul>
<li>在MybatisUtils工具类创建的时候实现自动提交事务！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编写接口，增加注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法存在多个参数，所有参数前面必须加上@Param(&quot;id&quot;)注解</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into user (id,name,pwd) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;password&#125; where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from user where id = #&#123;uid&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="meta">@Param(&quot;uid&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试类</li>
</ul>
<p>【注意：我们必须要将接口注册绑定到我们的核心配置文件中！】</p>
<p>关于@Param()注解</p>
<ul>
<li>基本类型的参数或者String类型，需要加上</li>
<li>引用类型不需要加</li>
<li>如果只有一个基本类型的话，可以忽略，但是建议都加上！</li>
<li>我们在SQL中引用的就是我们这里的@Param(“”)中设定的属性名！<br>#{}和${}区别</li>
</ul>
<h2 id="多对一处理"><a href="#多对一处理" class="headerlink" title="多对一处理"></a>多对一处理</h2><p>多对一：</p>
<ul>
<li>多个学生，对应一个老师</li>
<li>对于学生而言，<strong>关联</strong>–多个学生，关联一个老师【多对一】</li>
<li>对于老师而言，<strong>集合</strong>–一个老师，有很多个学生【一对多】</li>
</ul>
<p>SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `teacher` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`name` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">)ENGINE <span class="operator">=</span> INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> teacher(`id`,`name`) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;秦老师&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`name` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`tid` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">	KEY `fktid`(`tid`),</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> `fktid` <span class="keyword">FOREIGN</span> KEY (`tid`) <span class="keyword">REFERENCES</span> `teacher` (`id`)</span><br><span class="line">)ENGINE <span class="operator">=</span> INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student`(`id`,`name`,`tid`) <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student`(`id`,`name`,`tid`) <span class="keyword">VALUES</span> (<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student`(`id`,`name`,`tid`) <span class="keyword">VALUES</span> (<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;小张&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student`(`id`,`name`,`tid`) <span class="keyword">VALUES</span> (<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;小李&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student`(`id`,`name`,`tid`) <span class="keyword">VALUES</span> (<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;小王&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="测试环境搭建"><a href="#测试环境搭建" class="headerlink" title="测试环境搭建"></a>测试环境搭建</h3><ul>
<li>导入Lombok</li>
<li>新建实体类Teacher，Student</li>
<li>建立Mapper接口</li>
<li>建立Mapper.XML文件</li>
<li>在核心配置文件中绑定注册我们的Mapper接口或者文件！【方式很多,随心选】</li>
<li>测试查询是否能够成功！</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="毋  豆"
      src="/images/touxiang.gif">
  <p class="site-author-name" itemprop="name">毋  豆</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wudou" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wudou" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:760237638@qq.com" title="Mail → mailto:760237638@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">毋  豆</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
