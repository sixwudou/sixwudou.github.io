<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-circle.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sixwudou.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="数据库连接查询(必会)1.****左连接****（左外连接）以左表为基准进行查询,左表数据会全部显示出来, 右表 如果和左表匹配 的数据则显示相应字段的数据,如果不匹配,则显示为NULL; 2.****右连接****（右外连接）以右表为基准进行查询,右表数据会全部显示出来, 右表 如果和左表匹配的数据则显示相应字段的数据,如果不匹配,则显示为NULL; 3.****全连接****就是先以左表进行左">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库">
<meta property="og:url" content="https://sixwudou.github.io/2022/02/12/%E6%95%B0%E6%8D%AE%E5%BA%93/index.html">
<meta property="og:site_name" content="毋  豆 Blog">
<meta property="og:description" content="数据库连接查询(必会)1.****左连接****（左外连接）以左表为基准进行查询,左表数据会全部显示出来, 右表 如果和左表匹配 的数据则显示相应字段的数据,如果不匹配,则显示为NULL; 2.****右连接****（右外连接）以右表为基准进行查询,右表数据会全部显示出来, 右表 如果和左表匹配的数据则显示相应字段的数据,如果不匹配,则显示为NULL; 3.****全连接****就是先以左表进行左">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps6BA9.tmp.png">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps6BAA.tmp.png">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps6BBB.tmp.png">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps6BBC.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps6BBD.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps6BCD.tmp.jpg">
<meta property="article:published_time" content="2022-02-12T10:02:16.000Z">
<meta property="article:modified_time" content="2022-02-12T12:16:18.025Z">
<meta property="article:author" content="毋  豆">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps6BA9.tmp.png">

<link rel="canonical" href="https://sixwudou.github.io/2022/02/12/%E6%95%B0%E6%8D%AE%E5%BA%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据库 | 毋  豆 Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
	<a target="_blank" rel="noopener" href="https://github.com/sixwudou" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">毋  豆 Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sixwudou.github.io/2022/02/12/%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.gif">
      <meta itemprop="name" content="毋  豆">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="毋  豆 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据库
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-12 18:02:16 / 修改时间：20:16:18" itemprop="dateCreated datePublished" datetime="2022-02-12T18:02:16+08:00">2022-02-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h1><h2 id="连接查询-必会"><a href="#连接查询-必会" class="headerlink" title="连接查询(必会)"></a>连接查询(必会)</h2><p>1.****左连接****（左外连接）以左表为基准进行查询,左表数据会全部显示出来, 右表 如果和左表匹配 的数据则显示相应字段的数据,如果不匹配,则显示为NULL;</p>
<p>2.****右连接****（右外连接）以右表为基准进行查询,右表数据会全部显示出来, 右表 如果和左表匹配的数据则显示相应字段的数据,如果不匹配,则显示为NULL;</p>
<p>3.****全连接****就是先以左表进行左外连接，然后以右表进行右外连接。</p>
<p>****内连接****：</p>
<p>显示表之间有连接匹配的所有行。</p>
<h2 id="聚合函数-必会"><a href="#聚合函数-必会" class="headerlink" title="聚合函数(必会)"></a>聚合函数(必会)</h2><p>聚合函数是对一组值进行计算并返回单一的值的函数，它经常与 select 语句中的 group by 子句一同使用。</p>
<p><strong>1)</strong> ****avg()****：返回的是指定组中的平均值，空值被忽略。</p>
<p><strong>2)</strong> ****count()****：返回的是指定组中的项目个数。</p>
<p><strong>3)</strong> ****max()****：返回指定数据中的最大值。</p>
<p><strong>4)</strong> ****min()****：返回指定数据中的最小值。</p>
<p><strong>5)</strong> ****sum()****：返回指定数据的和，只能用于数字列，空值忽略。</p>
<p><strong>6)</strong> ****group by()****：对数据进行分组，对执行完 group by 之后的组进行聚合函数的运算，计算每一组的值。最后用 having 去掉不符合条件的组，having 子句中的每一个元素必须出现在 select 列表中（只针对于 mysql）。</p>
<h2 id="SQL注入-必会"><a href="#SQL注入-必会" class="headerlink" title="SQL注入(必会)"></a>SQL注入(必会)</h2><p>举例：</p>
<p>select admin from user where username=’admin’ or ‘a’=’a’ and passwd=’’or ‘a’=’a’</p>
<p>防止 SQL 注入，使用预编译语句是预防 SQL 注入的最佳方式，如</p>
<p>select admin from user where username=？And password=?</p>
<p>使用预编译的 SQL 语句语义不会发生改变，在 SQL 语句中，变量用问号？ 表示。像上面例子中，username 变量传递的’admin’ or ‘a’=’a’ 参数，也只会当 作 username 字符串来解释查询，从根本上杜绝了 SQL 注入攻击的发生。</p>
<p>注意：使用 mybaits 时 mapper 中#方式能够很大程度防止 SQL 注入，$方式 无法防止 SQL 注入.</p>
<h2 id="Select-语句完整的执行顺序-必会"><a href="#Select-语句完整的执行顺序-必会" class="headerlink" title="Select*语句完整的执行顺序(必会)"></a>Select*语句完整的执行顺序(必会)</h2><p>查询中用到的关键词主要包含六个，并且他们的顺序依次为<em><strong>*select–from–where–group by–having–order by*</strong></em></p>
<p>其中 <em><strong>*select*</strong></em> 和 <em><strong>*from*</strong></em> 是必须的，其他关键词是可选的， 这六个关键词的执行顺序如下：</p>
<p><em><strong>*from*</strong></em>: 需要从哪个数据表检索数据</p>
<p><em><strong>*where*</strong></em>: 过滤表中数据的条件</p>
<p><em><strong>*group by*</strong></em>: 如何将上面过滤出的数据分组算结果</p>
<p><em><strong>*order by*</strong></em> : 按照什么样的顺序来查看返回的数据</p>
<h2 id="存储引擎（高薪常问）"><a href="#存储引擎（高薪常问）" class="headerlink" title="存储引擎（高薪常问）"></a>存储引擎（高薪常问）</h2><h3 id="3-5-1-概念"><a href="#3-5-1-概念" class="headerlink" title="*3.5.1* *概念*"></a><em><strong>*3.5.1*</strong></em> <em><strong>*<strong>概念</strong>*</strong></em></h3><p>数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建.查询. 更新和删除数据。不同的存储引擎提供不同的存储机制.</p>
<p>索引技巧.锁定水平等功能，使用不同 的存储引擎，还可以 获得特定的功能。<br>        现在许多不同的数据库管理系统都支持多种不同的数据引擎。</p>
<p>存储引擎主要有： 1. MyIsam , 2. InnoDB, 3. Memory, 4. Archive, 5.Federated 。</p>
<h3 id="3-5-2-InnoDB"><a href="#3-5-2-InnoDB" class="headerlink" title="*3.5.2* *InnoDB*"></a><em><strong>*3.5.2*</strong></em> <strong>*InnoDB*</strong></h3><p>InnoDB 底层存储结构为B+树，B 树的每个节点对应innodb 的一个page， page 大小是固定的， 一般设为 16k。其中非叶子节点只有键值，叶子节点包含完成数据。</p>
<p>适 用 场 景 ：</p>
<p>1）经常更新的表，适合处理多重并发的更新请求。</p>
<p>2）支持事务。</p>
<p>3）可以从灾难中恢复（通过 bin-log 日志等）。</p>
<p>4）外键约束。只有他支持外键。       </p>
<p>5）支持自动增加列属性 auto_increment。</p>
<h3 id="3-5-3-TokuDB"><a href="#3-5-3-TokuDB" class="headerlink" title="*3.5.3* *TokuDB*"></a><em><strong>*3.5.3*</strong></em> <strong>*TokuDB*</strong></h3><p>TokuDB 底层存储结构为 Fractal Tree,Fractal Tree 的结构与 B+树有些类似, 在 Fractal Tree 中，每一个 child 指针除了需要指向一个 child 节点外， 还会带有一个 Message Buffer ，这个 Message Buffer 是一个 FIFO 的队列， 用来缓存更新操作。</p>
<p>例如，一次插入操作只需要落在某节点的 Message Buffer 就可以马上返回了，并不需要搜索到叶 子节点。这些缓存的更新会在查询时或后台异步合并应用到对应的节点中。</p>
<p>TokuDB 在线添加索引，不影响读写操作, 非常快的写入性能，</p>
<p>Fractal-tree 在事务实现上有优势。 他主要适用于访问频率不高的数据或历史数据归档。</p>
<h3 id="3-5-4-MyIASM"><a href="#3-5-4-MyIASM" class="headerlink" title="*3.5.4* *MyIASM*"></a><em><strong>*3.5.4*</strong></em> <strong>*MyIASM*</strong></h3><p>​    MyIASM 是 MySQL 默认的引擎，但是它没有提供对数据库事务的支持， 也不支持行级锁和外键， 因此当 INSERT(插入)或 UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。</p>
<p>​    ISAM 执行读取操作的速度很快，而且不占用大量的内存和存储资源。在设计之初就预想数据组织 成有固定长度的记录，按顺序存储的。—ISAM 是一种静态索引结构。 缺点是它不 支持事务处理。</p>
<h3 id="3-5-5-Memory"><a href="#3-5-5-Memory" class="headerlink" title="*3.5.5* *Memory*"></a><em><strong>*3.5.5*</strong></em> <em><strong>*<em>Memory</em>*</strong></em></h3><p>Memory（也叫 HEAP）堆内存：使用存在内存中的内容来创建表。每个MEMORY 表只实际对应 一个磁盘文件。MEMORY 类型的表访问非常得快， 因为它的数据是放在内存中的，并且默认使用 HASH 索引。但是一旦服务关闭， 表中的数据就会丢失掉。 Memory 同时支持散列索引和 B 树索 引，B 树索引可以使用部分查询和通配查询，也可以使用和&gt;=等操作符方便数据挖掘，散列索 引相等的比较快但是对于范围的比较慢很多。</p>
<h2 id="索引（高薪常问）"><a href="#索引（高薪常问）" class="headerlink" title="索引（高薪常问）"></a>索引（<em>高薪常问</em>）</h2><p>索引（Index）是帮助 MySQL 高效获取数据的数据结构。常见的查询算法, 顺序查找,二分查找,二 叉排序树查找,哈希散列法,分块查找,平衡多路搜索树 B 树（B-tree）</p>
<p>索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。</p>
<p>MySQL 数据库几个基本的索引类型：普通索引.唯一索引.主键索引.全文索引.组合索引</p>
<h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>是最基本的索引，它没有任何限制。它有以下几种创建方式：</p>
<p><strong>（1）</strong> <em><strong>*直接创建索引*</strong></em></p>
<p>CREATE INDEX index_name ON table(column[length]))</p>
<p><strong>（2）</strong> <em><strong>*修改表结构的方式添加索引*</strong></em></p>
<p>ALTER TABLE table_name ADD INDEX index_name ON (column[length]))</p>
<p><strong>（3）</strong> <img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps6BA9.tmp.png" alt="img"><em><strong>*创建表的时候同时创建索引*</strong></em></p>
<table>
<thead>
<tr>
<th>1</th>
<th>CREATE TABLE <code>table</code> (</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td><code>id</code> int(11) NOT NULL AUTO_INCREMENT ,</td>
</tr>
<tr>
<td>3</td>
<td><code>title</code> char(255) CHARACTER NOT NULL ,</td>
</tr>
<tr>
<td>4</td>
<td><code>content</code> text CHARACTER NULL ,</td>
</tr>
<tr>
<td>5</td>
<td><code>time</code> int(10) NULL DEFAULT NULL ,</td>
</tr>
<tr>
<td>6</td>
<td>PRIMARY KEY (<code>id</code>)</td>
</tr>
<tr>
<td>7</td>
<td>INDEX index_name (title[length])</td>
</tr>
<tr>
<td>8</td>
<td>)</td>
</tr>
</tbody></table>
<p><strong>（4）</strong> <strong>删除索引</strong></p>
<p>DROP INDEX index_name ON table</p>
<h3 id="3-6-2-唯一索引"><a href="#3-6-2-唯一索引" class="headerlink" title="*3.6.2* *唯一索引*"></a><em><strong>*3.6.2*</strong></em> <em><strong>*唯一索引*</strong></em></h3><p>与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：</p>
<p>（1） 创建唯一索引</p>
<p>CREATE UNIQUE INDEX indexName ON table(column[length])</p>
<p>（2） 修改表结构</p>
<p>ALTER TABLE table_name ADD UNIQUE indexName ON (column[length])</p>
<p>（3） 创建表的时候直接指定</p>
<table>
<thead>
<tr>
<th>1</th>
<th>CREATE TABLE <code>table</code> (</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td><code>id</code> int(11) NOT NULL AUTO_INCREMENT ,</td>
</tr>
<tr>
<td>3</td>
<td><code>title</code> char(255) CHARACTER NOT NULL ,</td>
</tr>
<tr>
<td>4</td>
<td><code>content</code> text CHARACTER NULL ,</td>
</tr>
<tr>
<td>5</td>
<td><code>time</code> int(10) NULL DEFAULT NULL ,</td>
</tr>
<tr>
<td>6</td>
<td>UNIQUE indexName (title[length])</td>
</tr>
<tr>
<td>7</td>
<td>);</td>
</tr>
</tbody></table>
<h3 id="3-6-3-主键索引"><a href="#3-6-3-主键索引" class="headerlink" title="*3.6.3 主键索引*"></a><em><strong>*3.6.3 主键索引*</strong></em></h3><p>是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引：</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps6BAA.tmp.png" alt="img"> </p>
<h3 id="3-6-4-组合索引"><a href="#3-6-4-组合索引" class="headerlink" title="*3.6.4* *组合索引*"></a><em><strong>*3.6.4*</strong></em> <em><strong>*组合索引*</strong></em></h3><p>指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合</p>
<p>ALTER TABLE <code>table</code> ADD INDEX name_city_age (name,city,age);</p>
<h3 id="3-6-5-全文索引"><a href="#3-6-5-全文索引" class="headerlink" title="*3.6.5* *全文索引*"></a><em><strong>*3.6.5*</strong></em> <em><strong>*全文索引*</strong></em></h3><p>主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext 索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的 where 语句的参数匹配。fulltext 索引配合 match against 操作使用，而不是一般的 where 语句加 like。它可以在 create table，alter table ，create index 使用，不过目前只有 char.varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用 CREATE index 创建 fulltext 索引，要比先为一张表建立 fulltext 然后再将数据写入的速度快很多。</p>
<table>
<thead>
<tr>
<th>1</th>
<th>CREATE TABLE <code>table</code> (</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td><code>id</code> int(11) NOT NULL AUTO_INCREMENT ,</td>
</tr>
<tr>
<td>3</td>
<td><code>title</code> char(255) CHARACTER NOT NULL ,</td>
</tr>
<tr>
<td>4</td>
<td><code>content</code> text CHARACTER NULL ,</td>
</tr>
<tr>
<td>5</td>
<td><code>time</code> int(10) NULL DEFAULT NULL ,</td>
</tr>
</tbody></table>
<p>（1） 创建表的适合添加全文索引</p>
<p>（2） <img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps6BBB.tmp.png" alt="img">修改表结构添加全文索引</p>
<p>ALTER TABLE article ADD FULLTEXT index_content(content)</p>
<p>（3） 直接创建全文索引</p>
<p>CREATE FULLTEXT INDEX index_content ON article(content)</p>
<h3 id="3-6-6-索引的优点"><a href="#3-6-6-索引的优点" class="headerlink" title="*3.6.6* *索引的优点*"></a><em><strong>*3.6.6*</strong></em> <em><strong>*索引的优点*</strong></em></h3><p>创建唯一索引，保证数据库表中每一行数据的唯一性大大加快数据的检索速度，这也是创建索引的最主要的原因</p>
<p>加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排</p>
<p>序的时间。</p>
<p>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。</p>
<h3 id="3-6-7-索引的缺点"><a href="#3-6-7-索引的缺点" class="headerlink" title="*3.6.7* *索引的缺点*"></a><em><strong>*3.6.7*</strong></em> <em><strong>*索引的缺点*</strong></em></h3><p>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</p>
<p>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大</p>
<p>当对表中的数据进行增加.删除和修改的时候，索引也要动态的维护，降低了数据的维护速度</p>
<h3 id="3-6-8-常见索引原则"><a href="#3-6-8-常见索引原则" class="headerlink" title="*3.6.8* *常见索引原则*"></a><em><strong>*3.6.8*</strong></em> <em><strong>*常见索引原则*</strong></em></h3><p>选择唯一性索引：唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。</p>
<p>为经常需要排序.分组和联合操作的字段建立索引. 为常作为查询条件的字段建立索引。</p>
<p>限制索引的数目：越多的索引，会使更新表变得很浪费时间。</p>
<p>尽量使用数据量少的索引：如果索引的值很长，那么查询的速度会受到影响。尽量使用前缀来索引：如果索引字段的值很长，最好使用值的前缀来索引。删除不再使用或者很少使用的索引</p>
<p>最左前缀匹配原则，非常重要的原则。</p>
<p>尽量选择区分度高的列作为索引：区分度的公式是表示字段不重复的比例索引列不能参与计算，保持列“干净”：带函数的查询不参与索引。</p>
<p>尽量的扩展索引，不要新建索引。</p>
<h2 id="索引原理（了解）"><a href="#索引原理（了解）" class="headerlink" title="索引原理（了解）"></a>索引原理（了解）</h2><p>我们使用索引，就是为了提高查询的效率，如同查书一样，先找到章，再找到章中对于的小节，再找到具体的页码，再到我们需要的内容。</p>
<p>事实上索引的本质就是不断缩小获取数据的筛选范围，找出我们想要的结果。同时把随机的事件变成顺序的事件，也就是说有了这种索引机制，我们就可以总是用同一种查找方式来锁定数据。</p>
<p>数据库也是一样，但显然要复杂的多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的。而数据库实现比较复杂，一方面数据是保存在磁盘上的，另外一方面为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。</p>
<h3 id="3-7-1-磁盘IO与预读"><a href="#3-7-1-磁盘IO与预读" class="headerlink" title="*3.7.1* *磁盘IO与预读*"></a><em><strong>*3.7.1*</strong></em> <em><strong>*磁盘IO与预读*</strong></em></h3><p>磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS（Million Instructions Per Second）的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行约450万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。下图是计算机硬件延迟的对比图，供大家参考：</p>
<p> <img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps6BBC.tmp.jpg" alt="img"></p>
<p>考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，****当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内****，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p>
<h3 id="3-7-2-B-树"><a href="#3-7-2-B-树" class="headerlink" title="*3.7.2* *B+树*"></a><em><strong>*3.7.2*</strong></em> <em><strong>*B+树*</strong></em></h3><p>上面说了磁盘io是很费时间的。当我们想要查询一个数据的时候，应该控制把磁盘IO控制在一个很小的数量级。而B+数应运而生（B+树是通过二叉查找树，再由平衡二叉树，B树演化而来）。<img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps6BBD.tmp.jpg" alt="img"></p>
<p>如上图，是一颗b+树，关于b+树的定义可以参见<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/B%2B%E6%A0%91">B+树</a>，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p>
<h3 id="3-7-3-B-树的查找过程"><a href="#3-7-3-B-树的查找过程" class="headerlink" title="*3.7.3 B**+树的查找过程*"></a><em><strong>*3.7.3 B*</strong></em><em><strong>*+树的查找过程*</strong></em></h3><p>如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p>
<h3 id="3-7-4-B-树性质"><a href="#3-7-4-B-树性质" class="headerlink" title="3.7.4 B+树性质"></a><strong>3.7.4 B</strong><strong>+树性质</strong></h3><p>1****.索引字段要尽量的小*<em><strong>：通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。<br>        2.</strong></em>*索引的最左匹配特性****：当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p>
<h3 id="3-7-5-聚焦索引和辅助索引"><a href="#3-7-5-聚焦索引和辅助索引" class="headerlink" title="*3.7.5* *聚焦索引和辅助索引*"></a><em><strong>*3.7.5*</strong></em> <em><strong>*聚焦索引和辅助索引*</strong></em></h3><p>在数据库中，B+树的高度一般都在2~4层，这也就是说查找某一个键值的行记录时最多只需要2到4次IO，这倒不错。</p>
<p>数据库中的B+树索引可以分为聚集索引（clustered index）和辅助索引（secondary index），</p>
<p>聚集索引与辅助索引相同的是：不管是聚集索引还是辅助索引，其内部都是B+树的形式，即高度是平衡的，叶子结点存放着所有的数据。</p>
<p>聚集索引与辅助索引不同的是：叶子结点存放的是否是一整行的信息</p>
<p><strong>1)</strong> <em><strong>*聚集索引*</strong></em></p>
<p>InnoDB存储引擎表示索引组织表，即表中数据按照主键顺序存放。而聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子结点存放的即为整张表的行记录数据，也将聚集索引的叶子结点称为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。</p>
<p>如果未定义主键，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚簇索引。</p>
<p>如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。</p>
<p>由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。在多少情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子节点上直接找到数据。此外由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值得查询。</p>
<p>聚集索引的好处</p>
<p>它对主键的排序查找和范围查找速度非常快，叶子节点的数据就是用户所要查询的数据。如用户需要查找一张表，查询最后的10位用户信息，由于B+树索引是双向链表，所以用户可以快速找到最后一个数据页，并取出10条记录</p>
<p>范围查询（range query），即如果要查找主键某一范围内的数据，通过叶子节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可</p>
<p><strong>2)</strong> <em><strong>*辅助索引*</strong></em></p>
<p>表中除了聚集索引外其他索引都是辅助索引（Secondary Index，也称为非聚集索引），与聚集索引的区别是：辅助索引的叶子节点不包含行记录的全部数据。</p>
<p>叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含一个书签（bookmark）。该书签用来告诉InnoDB存储引擎去哪里可以找到与索引相对应的行数据。</p>
<p>由于InnoDB存储引擎是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。</p>
<p>辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引，但只能有一个聚集索引。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶子级别的指针获得相应的主键索引的主键，然后再通过主键索引来找到一个完整的行记录。</p>
<p>举例来说，如果在一棵高度为3的辅助索引树种查找数据，那需要对这个辅助索引树遍历3次找到指定主键，如果聚集索引树的高度同样为3，那么还需要对聚集索引树进行3次查找，最终找到一个完整的行数据所在的页，因此一共需要6次逻辑IO访问才能得到最终的一个数据页。</p>
<h2 id="3-8-数据库三范式-必会"><a href="#3-8-数据库三范式-必会" class="headerlink" title="*3.8* *数据库三范式**(必会)*"></a><em><strong>*3.8*</strong></em> <em><strong>*数据库三范式*</strong></em><em><strong>*(必会)*</strong></em></h2><p>范式是具有最小冗余的表结构。3 范式具体如下：</p>
<h3 id="3-8-1-第一范式-1st-NF-－First-Normal-Fromate"><a href="#3-8-1-第一范式-1st-NF-－First-Normal-Fromate" class="headerlink" title="*3.8.1* *第一范式(1st* *NF* *－First Normal Fromate)*"></a><em><strong>*3.8.1*</strong></em> <em><strong>*第一范式(1st*</strong></em> <em><strong>*NF*</strong></em> <em><strong>*－First Normal Fromate)*</strong></em></h3><p>第一范式的目标是确保每列的原子性:如果每列都是不可再分的最小数据单元（也称为最小的原子  单元），则满足第一范式（1NF）</p>
<p>第一范式（1NF）要求数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值。</p>
<p>若某一列有多个值，可以将该列单独拆分成一个实体，新实体和原实体间是一对多的关系。 </p>
<p>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。</p>
<p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</p>
<p>第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份.城市.详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式</p>
<h3 id="3-8-2-第二范式-2nd-NF－Second-Normal-Fromate"><a href="#3-8-2-第二范式-2nd-NF－Second-Normal-Fromate" class="headerlink" title="*3.8.2* *第二范式(2nd* *NF－Second Normal Fromate)*"></a><em><strong>*3.8.2*</strong></em> <em><strong>*第二范式(2nd*</strong></em> <em><strong>*NF－Second Normal Fromate)*</strong></em></h3><p>首先满足第一范式，并且表中非主键列不存在对主键的部分依赖。 第二范式要求每个表只描述一 件事情。</p>
<p>满足第二范式（2NF）必须先满足第一范式（1NF）。</p>
<p>第二范式要求实体中没一行的所有非主属性都必须完全依赖于主键；即：非主属性必须完全依赖于主键。</p>
<p>完全依赖：主键可能由多个属性构成，完全依赖要求不允许存在非主属性依赖于主键中的某一部分属性。</p>
<p>若存在哪个非主属性依赖于主键中的一部分属性，那么要将发生部分依赖的这一组属性单独新建一个实体，并且在旧实体中用外键与新实体关联，并且新实体与旧实体间是一对多的关系。</p>
<p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保 存在同一张数据库表中。</p>
<h3 id="3-8-3-第三范式-3rd-NF-－-Third-Normal-Fromate"><a href="#3-8-3-第三范式-3rd-NF-－-Third-Normal-Fromate" class="headerlink" title="*3.8.3* *第三范式(3rd* *NF**－* *Third Normal Fromate)*"></a><em><strong>*3.8.3*</strong></em> <em><strong>*第三范式(3rd*</strong></em> <em><strong>*NF*</strong></em><em><strong>*－*</strong></em> <em><strong>*Third Normal Fromate)*</strong></em></h3><p>第三范式定义是，满足第二范式，并且表中的列不存在对非主键列的传递依赖。除了主键订单编号外，顾客姓名依赖于非主键顾客编号。</p>
<p>满足第三范式必须先满足第二范式。</p>
<p>第三范式要求：实体中的属性不能是其他实体中的非主属性。因为这样会出现冗余。即：属性不依赖于其他非主属性。</p>
<p>如果一个实体中出现其他实体的非主属性，可以将这两个实体用外键关联， 而不是将另一张表的非主属性直接写在当前表中。</p>
<p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</p>
<h2 id="3-9-数据库事务-必会"><a href="#3-9-数据库事务-必会" class="headerlink" title="*3.9* *数据库事务**(必会)*"></a><em><strong>*3.9*</strong></em> <em><strong>*数据库事务*</strong></em><em><strong>*(必会)*</strong></em></h2><h3 id="3-9-1-事务-TRANSACTION"><a href="#3-9-1-事务-TRANSACTION" class="headerlink" title="*3.9.1* *事务(TRANSACTION)*"></a><em><strong>*3.9.1*</strong></em> <em><strong>*事务(TRANSACTION)*</strong></em></h3><p>​    是作为单个逻辑工作单元执行的一系列操作，这些操作作为一个整体一起向系统提交，要么都执行.要么都不执行。事务是一个不可分割的工作逻辑单元 事务必须具备以下四个属性，简称 ACID 属性：</p>
<p>A  ****原子性（Atomicity）****：事务是一个完整的操作。事务的各步操作是不可分的（原子的）；要  么都执行，要么都不执行。</p>
<p>B ****一致性（Consistency）****：当事务完成时，数据必须处于一致状态。</p>
<p>C  ****隔离性（Isolation）****：对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独 立的，它不应以任何方式依赖于或影响其他事务。</p>
<p>D  ****永久性（Durability）****：事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务 的永久性。</p>
<h3 id="3-9-2-事务控制语句"><a href="#3-9-2-事务控制语句" class="headerlink" title="3.9.2 事务控制语句"></a>3.9.2 事务控制语句</h3><p><em><strong>*BEGIN*</strong></em> 或 S<em><strong>*TART TRANSACTION*</strong></em> 显式地开启一个事务；</p>
<p><em><strong>*COMMIT*</strong></em> 也可以使用 <em><strong>*COMMIT WORK*<em><strong>，不过二者是等价的。</strong></em>*COMMIT*</strong></em> 会提交事务，并使已对数据库进行的所有修改成为永久性的；</p>
<p><em><strong>*ROLLBACK*</strong></em> 也可以使用 ****ROLLBACK WORK****，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</p>
<p><em><strong>*SAVEPOINT identifier*<em><strong>，</strong></em>*SAVEPOINT*</strong></em> 允许在事务中创建一个保存点，一个事务中可以有多个 ****SAVEPOINT****；</p>
<p><em><strong>*RELEASE SAVEPOINT identifier*</strong></em> 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</p>
<p><em><strong>*ROLLBACK TO identifier*</strong></em> 把事务回滚到标记点；</p>
<p><em><strong>*SET TRANSACTION*</strong></em> 用来设置事务的隔离级别。</p>
<p>InnoDB 存储引 擎 提 供 事 务 的 隔 离 级 别 有 <em><strong>*READ*</strong></em> <em><strong>*UNCOMMITTED.READ COMMITTED.REPEATABLE READ*</strong></em> 和 <em><strong>*SERIALIZABLE*</strong></em> 。</p>
<h3 id="3-9-3-MySQL-事务处理主要有两种方法："><a href="#3-9-3-MySQL-事务处理主要有两种方法：" class="headerlink" title="*3.9.3* *MySQL 事务处理主要有两种方法：*"></a><em><strong>*3.9.3*</strong></em> <em><strong>*MySQL 事务处理主要有两种方法：*</strong></em></h3><p>a) 用 BEGIN, ROLLBACK, COMMIT 来实现</p>
<p><strong>i.</strong> <em><strong>*BEGIN*</strong></em> 开始一个事务</p>
<p><strong>ii.</strong> <em><strong>*ROLLBACK*</strong></em> 事务回滚</p>
<p><strong>iii.</strong>   <em><strong>*COMMIT*</strong></em> 事务确认</p>
<p>b) 直接用 SET 来改变 MySQL 的自动提交模式:</p>
<p><strong>i.</strong> <em><strong>*SET*</strong></em> <em><strong>*AUTOCOMMIT=0*</strong></em> 禁止自动提交</p>
<p><strong>ii.</strong> <em><strong>*SET*</strong></em> <em><strong>*AUTOCOMMIT=1*</strong></em> 开启自动提交</p>
<h3 id="3-9-4-事务的四种隔离级别"><a href="#3-9-4-事务的四种隔离级别" class="headerlink" title="*3.9.4* *事务的四种隔离级别*"></a><em><strong>*3.9.4*</strong></em> <em><strong>*事务的四种隔离级别*</strong></em></h3><p><em><strong>*1）*</strong></em><em><strong>*Read uncommitted*</strong></em></p>
<p>读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。</p>
<p><em><strong>*2）*</strong></em><em><strong>*Read committed*</strong></em></p>
<p>读已提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数</p>
<p><em><strong>*3）*</strong></em><em><strong>*Repeatable read*</strong></em></p>
<p>可重复读，就是在开始读取数据（事务开启）时，不再允许修改操作</p>
<p><em><strong>*4）*</strong></em><em><strong>*Serializable 序列化*</strong></em></p>
<p>Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读.不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</p>
<p><strong>在</strong> <strong>MySQL</strong> <strong>数据库中，支持上面四种隔离级别，默认的为</strong> <strong>Repeatable read</strong> **(可重复读)**；而在 Oracle 数据库中，只支持 Serializable (串行化)级别和 Read committed (读已提交)这两种级别，其中默认的为 Read committed 级别。</p>
<h2 id="3-10-存储过程-（高薪常问）"><a href="#3-10-存储过程-（高薪常问）" class="headerlink" title="*3.10* *存储过程**（高薪常问）*"></a><em><strong>*3.10*</strong></em> <em><strong>*存储过程*</strong></em><em><strong>*（高薪常问）*</strong></em></h2><p>一组为了完成特定功能的 SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次 编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过 程是数据库中的一个重要对象。</p>
<p>存储过程优化思路：</p>
<p>\1. 尽量利用一些 SQL 语句来替代一些小循环，例如聚合函数，求平均函数等。</p>
<p>\2. 中间结果存放于临时表，加索引。</p>
<p>\3. 少使用游标。SQL 是个集合语言，对于集合运算具有较高性能。而cursors是<br>过程运算。比 如对一个 100 万行的数据进行查询。游标需要读表100 万次，而不<br>使用游标则只需要少量几次读取。</p>
<p>\4. 事务越短越好。SQLserver 支持并发操作。如果事务过多过长，或者隔离级<br>别过高，都会造 成并发操作的阻塞，死锁。导致查询极慢，cpu 占用率极地。</p>
<p>\5. 使用 try-catch 处理错误异常。</p>
<p>\6. 查找语句尽量不要放在循环内。</p>
<h2 id="3-11-数据库并发策略-（高薪常问）"><a href="#3-11-数据库并发策略-（高薪常问）" class="headerlink" title="*3.11* *数据库并发策略**（高薪常问）*"></a><em><strong>*3.11*</strong></em> <em><strong>*数据库并发策略*</strong></em><em><strong>*（高薪常问）*</strong></em></h2><p>并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳。</p>
<h3 id="3-1-1-1-乐观锁"><a href="#3-1-1-1-乐观锁" class="headerlink" title="*3.1**1**.1 乐观锁*"></a><em><strong>*3.1*</strong></em><em><strong>*1*</strong></em><em><strong>*.1 乐观锁*</strong></em></h3><p>乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自 己读数据库的时候，别人可能刚好在写自己刚读的数据， 其实就是持一种比较保守的态度；时间 戳就是不加锁，通过时间戳来控制并发出现的问题。</p>
<h3 id="3-11-2-悲观锁"><a href="#3-11-2-悲观锁" class="headerlink" title="*3.11.2* *悲观锁*"></a><em><strong>*3.11.2*</strong></em> <em><strong>*悲观锁*</strong></em></h3><p>悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加 锁，只有自己把数据读完了，才允许别人修改那部分数据， 或者反过来说，就是自己修改某条数 据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允 许其他用户访问那部分数据。</p>
<h3 id="3-11-3-两种锁的使用场景"><a href="#3-11-3-两种锁的使用场景" class="headerlink" title="*3.11.3* *两种锁的使用场景*"></a><em><strong>*3.11.3*</strong></em> <em><strong>*两种锁的使用场景*</strong></em></h3><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行 retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p>
<h3 id="3-11-4-乐观锁常见的两种实现式版本号机制"><a href="#3-11-4-乐观锁常见的两种实现式版本号机制" class="headerlink" title="3.11.4 乐观锁常见的两种实现式版本号机制"></a>3.11.4 乐观锁常见的两种实现式版本号机制</h3><p>一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数，当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。CAS 算法即 compare and swap（比较与交换），是一种有名的无锁算法。</p>
<p>无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS 算法涉及到三个操作数</p>
<p>需要读写的内存值 </p>
<p>V 进行比较的值 A</p>
<p>拟写入的新值 B</p>
<p>当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值， 否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p>
<h3 id="3-11-5-乐观锁的缺点"><a href="#3-11-5-乐观锁的缺点" class="headerlink" title="*3.11.5* *乐观锁的缺点*"></a><em><strong>*3.11.5*</strong></em> <em><strong>*乐观锁的缺点*</strong></em></h3><p><em><strong>*ABA 问 题*</strong></em></p>
<p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 “ABA”问题。</p>
<p>JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<p><em><strong>*循环时间长开销大*</strong></em></p>
<p>自旋 CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功， 会给 CPU 带来非常大的执行开销。 如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起 CPU 流水线被清空（CPU pipeline flush），从而提高 CPU 的执行效率。</p>
<p><em><strong>*只能保证一个共享变量的原子操作*</strong></em></p>
<p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了 AtomicReference 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用 AtomicReference 类把多个共享变量合并成一个共享变量来操作</p>
<p><em><strong>*CAS 与 synchronized 的使用情景*</strong></em></p>
<p>简单的来说 CAS 适用于写比较少的情况下（多读场景，冲突一般较少）， synchronized 适用于写比较多的情况下（多写场景，冲突一般较多）</p>
<p>对于资源竞争较少（线程冲突较轻）的情况，使用 synchronized 同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu 资源； 而 CAS 基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少， 因此可以获得更高的性能。</p>
<p>对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大， 从而浪费更多的 CPU 资源，效率低于 synchronized。</p>
<p>补充： Java 并发编程这个领域中 synchronized 关键字一直都是元老级的</p>
<p>角色，很久之前很多人都会称它为 “重量级锁” 。但是，在 JavaSE 1.6 之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。</p>
<p>synchronized 的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞， 竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较 少的情况下，可以获得和 CAS 类似的性能；而线程冲突严重的情况下，性能远高于 CAS<strong>。</strong></p>
<h3 id="3-11-6-时间戳"><a href="#3-11-6-时间戳" class="headerlink" title="*3.11.6* *时间戳*"></a><em><strong>*3.11.6*</strong></em> <em><strong>*时间戳*</strong></em></h3><p>时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字 段也读出来，当写回去的时候，把该字段加 1，提交之前 ， 跟数据库的该字段比较一次，如果比数 据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁 机制，但是这种方法可以大大提高数据库处理的并发量，</p>
<p>以上悲观锁所说的加“锁”，其实分为几种锁，分别是：排它锁（写锁）和共享锁（读锁）。</p>
<h2 id="3-12-触发器-（高薪常问）"><a href="#3-12-触发器-（高薪常问）" class="headerlink" title="*3.12* *触发器**（高薪常问）*"></a><em><strong>*3.12*</strong></em> <em><strong>*触发器*</strong></em><em><strong>*（高薪常问）*</strong></em></h2><p>触发器是一段能自动执行的程序，是一种特殊的存储过程，触发器和普通的存储过程的区别是： 触发器是当对某一个表进行操作时触发。诸如： update.insert.delete 这些操作的时候，系统 会自动调用执行该表上对应的触发器。SQL Server 2005 中触发器可以分为两类：DML 触发器和 DDL 触发器，其中 DDL 触发器它们会影响多种数据定义语言语句而激发，这些语句有create. alter.drop 语句。</p>
<h2 id="3-13-数据库锁-（高薪常问）"><a href="#3-13-数据库锁-（高薪常问）" class="headerlink" title="*3.13* *数据库锁**（高薪常问）*"></a><em><strong>*3.13*</strong></em> <em><strong>*数据库锁*</strong></em><em><strong>*（高薪常问）*</strong></em></h2><h3 id="3-13-1-行级锁"><a href="#3-13-1-行级锁" class="headerlink" title="*3.13.1* *行级锁*"></a><em><strong>*3.13.1*</strong></em> <em><strong>*行级锁*</strong></em></h3><p>行级锁是一种排他锁，防止其他事务修改此行；在使用以下语句时，Oracle 会自动应用行级锁：</p>
<p>INSERT.UPDATE.DELETE.SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT];</p>
<p>SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新</p>
<p>使用 COMMIT 或 ROLLBACK 语句释放锁。</p>
<h3 id="3-13-2-表级锁"><a href="#3-13-2-表级锁" class="headerlink" title="*3.13.2* *表级锁*"></a><em><strong>*3.13.2*</strong></em> <em><strong>*表级锁*</strong></em></h3><p>表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL 引擎支持。最常使 用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁 （排他锁）。</p>
<h3 id="3-13-3-页级锁"><a href="#3-13-3-页级锁" class="headerlink" title="*3.13.3* *页级锁*"></a><em><strong>*3.13.3*</strong></em> <em><strong>*页级锁*</strong></em></h3><p>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级 冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB 支持页级锁</p>
<h2 id="3-14-基于-Redis-分布式锁-（高薪常问）"><a href="#3-14-基于-Redis-分布式锁-（高薪常问）" class="headerlink" title="*3.14* *基于* *Redis* *分布式锁**（高薪常问）*"></a><em><strong>*3.14*</strong></em> <em><strong>*基于*</strong></em> <em><strong>*Redis*</strong></em> <em><strong>*分布式锁*</strong></em><em><strong>*（高薪常问）*</strong></em></h2><p>\1. 获取锁的时候，使用 setnx（ETNX key val：当且仅当 key 不存在时， set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0） 加锁，锁的 value 值为一个随机生成的 UUID，在释放锁的时候进行判断。并使用 expire 命令为锁添 加一个超时时间，超过该时间则自动释放锁。</p>
<p>\2. 获取锁的时候调用 setnx，如果返回 0，则该锁正在被别人使用，返回 1 则成功获取 锁。 还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</p>
<p>\3. 释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</p>
<h2 id="3-15-分区分表-（高薪常问）"><a href="#3-15-分区分表-（高薪常问）" class="headerlink" title="*3.15* *分区分表**（高薪常问）*"></a><em><strong>*3.15*</strong></em> <em><strong>*分区分表*</strong></em><em><strong>*（高薪常问）*</strong></em></h2><p>分库分表有垂直切分和水平切分两种。</p>
<p><strong>▪</strong> ****垂直切分****：将表按照功能模块.关系密切程度划分出来，部署到不同的库上。例如，我们会 建立定义数据库 workDB.商品数据库 payDB.用户数据库userDB.日志数据库 logDB 等，分别用于存储项目数据定义表.商品定义表.用户数据表.日志数据表等。</p>
<p><strong>▪</strong> ****水平切分****：当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如 userID 散列，进行划分，然后存储到多个结构相同的表，和不同的库上。例如，我们的 userDB 中的用户数据表中，每一个表的数据量都很大， 就可以把 userDB 切分为结构相同的多个 userDB：part0DB.part1DB 等，再将 userDB 上 的 用 户 数 据 表 userTable， 切 分 为 很 多 userTable： userTable0.userTable1 等，然后将这些表按照一定的规则存储到多个 userDB 上。</p>
<h2 id="3-16-应该使用哪一种方式来实施数据库分库分表，这要看数据库中数据量的瓶颈所在，并综合项目的业务类型进行考虑。-（了解）"><a href="#3-16-应该使用哪一种方式来实施数据库分库分表，这要看数据库中数据量的瓶颈所在，并综合项目的业务类型进行考虑。-（了解）" class="headerlink" title="*3.16* *应该使用哪一种方式来实施数据库分库分表，这要看数据库中数据量的瓶颈所在，并综合项目的业务类型进行考虑。**（了解）*"></a><em><strong>*3.16*</strong></em> <em><strong>*应该使用哪一种方式来实施数据库分库分表，这要看数据库中数据量的瓶颈所在，并综合项目的业务类型进行考虑。*</strong></em><em><strong>*（了解）*</strong></em></h2><p>如果数据库是因为表太多而造成海量数据，并且项目的各项业务逻辑划分清晰. 低耦合，那么规则简单明了.容易实施的垂直切分必是首选。</p>
<p>而如果数据库中的表并不多，但单表的数据量很大.或数据热度很高，这种情况 之下就应该选择水平切分，水平切分比垂直切分要复杂一些，它将原本逻辑上属 于一体的数据进行了物理分割，除了在分割时要对分割的粒度做好评估， 考虑数 据平均和负载平均，后期也将对项目人员及应用程序产生额外的数据管理负担。 在现实项目中，往往是这两种情况兼而有之，这就需要做出权衡，甚至既需要垂 直切分，又需要水平切分。我们的游戏项目便综合使用了垂直与水平切分，我们 首先对数据库进行垂直切分，然后，再针对一部分表，通常是用户数据表，进行 水平切分。</p>
<p>单库多表 ：</p>
<p>随着用户数量的增加，user 表的数据量会越来越大，当数据量达到一定 程度的时候对 user 表的查询会渐渐的变慢，从而影响整个 DB 的性能。如果使用 MySQL, 还有一个更严重的问题是，当需要添加一列的时候，MySQL 会锁表， 期间所有的读写操作只能等待。</p>
<p>可以将 user 进行水平的切分，产生两个表结构完全一样的user_0000,user_0001 等表，user_0000 + user_0001 + …的数据刚好是一份完整的数据。</p>
<p><em><strong>*多库多表*</strong></em> ：</p>
<p>随着数据量增加也许单台 DB 的存储空间不够，随着查询量的增加单台数据 库服务器已经没办法支撑。这个时候可以再对数据库进行水平区分。</p>
<p>分库分表规则举例： 通过分库分表规则查找到对应的表和库的过程。如分库分表的规则是 user_id 除以 4 的方式，当用户新注册了一个账号，账号 id 的 123,我们可以通过 id 除以 4 的方式确定此账号应该保存到 User_0003 表中。当用户 123 登录的时 候，我们通过 123 除以 4 后确定记录在User_0003 中 。</p>
<h2 id="3-17-MySQL-读写分离-（高薪常问）"><a href="#3-17-MySQL-读写分离-（高薪常问）" class="headerlink" title="*3.17* *MySQL* *读写分离**（高薪常问）*"></a><em><strong>*3.17*</strong></em> <em><strong>*MySQL*</strong></em> <em><strong>*读写分离*</strong></em><em><strong>*（高薪常问）*</strong></em></h2><p>在实际的应用中，绝大部分情况都是读远大于写。MySQL 提供了读写分离的机制，所有的写操作都必须对应到 Master，读操作可以在 Master 和 Slave 机 器上进行，Slave 与 Master 的结构完全一样，一个 Master 可以有多个Slave,甚 至 Slave 下还可以挂 Slave,通过此方式可以有效的提高 DB 集群的每秒查询率. 所有的写操作都是先在 Master 上操作，然后同步更新到 Slave上，所以 从 Master 同步到 Slave 机器有一定的延迟，当系统很繁忙的时候， 延迟问题会 更加严重，Slave 机器数量的增加也会使这个问题更加严重。此外，可以看出 Master 是集群的瓶颈，当写操作过多，会严重影响到Master 的 稳定性，如果 Master 挂掉，整个集群都将不能正常工作。 所以，</p>
<p>\1. 当读压力很大的时候，可以考虑添加 Slave 机器的分式解决，但是当 Slave 机器达到一定的数量就得考虑分库了。 </p>
<p>\2. 当写压力很大的时候，就必须 得进行分库操作。</p>
<h2 id="3-18-MySQL-常用-30-种-SQL-查询语句优化方法-必会"><a href="#3-18-MySQL-常用-30-种-SQL-查询语句优化方法-必会" class="headerlink" title="*3.18* *MySQL* *常用* *30* *种* *SQL* *查询语句优化方法**(必会)*"></a><em><strong>*3.18*</strong></em> <em><strong>*MySQL*</strong></em> <em><strong>*常用*</strong></em> <em><strong>*30*</strong></em> <em><strong>*种*</strong></em> <em><strong>*SQL*</strong></em> <em><strong>*查询语句优化方法*</strong></em><em><strong>*(必会)*</strong></em></h2><p>\1. 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</p>
<p>\2. 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
<p>\3. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。如：</p>
<p>select id from t where num is null</p>
<p>可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询：</p>
<p>select id from t where num=0</p>
<p>\4. 尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<p>select id from t where num=10 or num=20 </p>
<p>可以这样查询：</p>
<p>select id from t where num=10</p>
<p>union all</p>
<p>select id from t where num=20</p>
<p>\5. 下面的查询也将导致全表扫描：(不能前置百分号) </p>
<p>select id from t where name like ‘%c%’</p>
<p>下面走索引</p>
<p>select id from t where name like ‘c%’ </p>
<p>若要提高效率，可以考虑全文检索。</p>
<p>\6. in 和 not in 也要慎用，否则会导致全表扫描，如： </p>
<p>select id from t where num in(1,2,3)</p>
<p>对于连续的数值，能用 between 就不要用 in 了：</p>
<p>select id from t where num between 1 and 3</p>
<p>\7. 如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p>
<p>select id from t where num=@num </p>
<p>可以改为强制查询使用索引：</p>
<p>select id from t with(index(索引名)) where num=@num</p>
<p>\8. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<p>select id from t where num/2=100</p>
<p>应改为:</p>
<p>select id from t where num=100*2</p>
<p>\9. 应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<p>select id from t where substring(name,1,3)=’abc’ –name 以 abc 开头的 id</p>
<p>select id from t where datediff(day,createdate,’2005-11-30′)=0 –’ 2005-11-30′生成的 id</p>
<p>应改为:</p>
<p>select id from t where name like ‘abc%’</p>
<p>select id from t where createdate&gt;=’2005-11-30′ and createdate&lt;’ 2005-12-1′</p>
<p>\10. 不要在 where 子句中的“=”左边进行函数.算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
<p>\11. 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使 用，并且应尽可能的让字段顺序与索引顺序相一致。</p>
<p>\12. 不要写一些没有意义的查询，如需要生成一个空表结构：</p>
<p> select col1,col2 into #t from t where 1=0</p>
<p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： </p>
<p>create table #t(…)</p>
<p>\13.  很多时候用 exists 代替 in 是一个好的选择：</p>
<p>select num from a where num in(select num from b)</p>
<p>用下面的语句替换：</p>
<p>select num from a where exists(select 1 from b where num=a.num) </p>
<p>\14.   并不是所有索引对查询都有效，SQL 是根据表中数据来进行查询优化的，</p>
<p>当索引列有大量数据重复时，SQL 查询可能不会去利用索引，如一表中有字段sex，male.female 几乎各一半，那么即使在 sex 上建了索引也对查询效率起不了作用。</p>
<p>\15.  索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数较好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</p>
<p>\16.  应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p>
<p>\17.  尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型， 这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
<p>\18.  尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
<p>\19.  任何地方都不要使用  select * from  ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p>
<p>\20.  尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p>
<p>\21.  避免频繁创建和删除临时表，以减少系统表资源的消耗。</p>
<p>\22.  临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如， 当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，较好使 用导出表。</p>
<p>\23.  在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大， 为了缓和系统表的资源，应先 create table，然后 insert。</p>
<p>\24.  如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除， 先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p>
<p>\25.  尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过 1 万行，那么就应该考虑改写。</p>
<p>\26.  使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p>
<p>\28.  与临时表一样，游标并不是不可使用。对小型数据集使用FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p>
<p>\29.  在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONEINPROC 消息。</p>
<p>\29. <img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps6BCD.tmp.jpg" alt="img"> 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p>
<p>\30.  尽量避免大事务操作，提高系统并发能力。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/12/JavaWeb/" rel="prev" title="JavaWeb">
      <i class="fa fa-chevron-left"></i> JavaWeb
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/12/Spring/" rel="next" title="Spring">
      Spring <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2-%E5%BF%85%E4%BC%9A"><span class="nav-number">1.1.</span> <span class="nav-text">连接查询(必会)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0-%E5%BF%85%E4%BC%9A"><span class="nav-number">1.2.</span> <span class="nav-text">聚合函数(必会)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E6%B3%A8%E5%85%A5-%E5%BF%85%E4%BC%9A"><span class="nav-number">1.3.</span> <span class="nav-text">SQL注入(必会)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Select-%E8%AF%AD%E5%8F%A5%E5%AE%8C%E6%95%B4%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-%E5%BF%85%E4%BC%9A"><span class="nav-number">1.4.</span> <span class="nav-text">Select*语句完整的执行顺序(必会)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%88%E9%AB%98%E8%96%AA%E5%B8%B8%E9%97%AE%EF%BC%89"><span class="nav-number">1.5.</span> <span class="nav-text">存储引擎（高薪常问）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-%E6%A6%82%E5%BF%B5"><span class="nav-number">1.5.1.</span> <span class="nav-text">*3.5.1* *概念*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-InnoDB"><span class="nav-number">1.5.2.</span> <span class="nav-text">*3.5.2* *InnoDB*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-3-TokuDB"><span class="nav-number">1.5.3.</span> <span class="nav-text">*3.5.3* *TokuDB*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-4-MyIASM"><span class="nav-number">1.5.4.</span> <span class="nav-text">*3.5.4* *MyIASM*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-5-Memory"><span class="nav-number">1.5.5.</span> <span class="nav-text">*3.5.5* *Memory*</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%EF%BC%88%E9%AB%98%E8%96%AA%E5%B8%B8%E9%97%AE%EF%BC%89"><span class="nav-number">1.6.</span> <span class="nav-text">索引（高薪常问）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95"><span class="nav-number">1.6.1.</span> <span class="nav-text">普通索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-2-%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="nav-number">1.6.2.</span> <span class="nav-text">*3.6.2* *唯一索引*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-3-%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="nav-number">1.6.3.</span> <span class="nav-text">*3.6.3 主键索引*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-4-%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-number">1.6.4.</span> <span class="nav-text">*3.6.4* *组合索引*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-5-%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="nav-number">1.6.5.</span> <span class="nav-text">*3.6.5* *全文索引*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-6-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">1.6.6.</span> <span class="nav-text">*3.6.6* *索引的优点*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-7-%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">1.6.7.</span> <span class="nav-text">*3.6.7* *索引的缺点*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-8-%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95%E5%8E%9F%E5%88%99"><span class="nav-number">1.6.8.</span> <span class="nav-text">*3.6.8* *常见索引原则*</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">1.7.</span> <span class="nav-text">索引原理（了解）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-1-%E7%A3%81%E7%9B%98IO%E4%B8%8E%E9%A2%84%E8%AF%BB"><span class="nav-number">1.7.1.</span> <span class="nav-text">*3.7.1* *磁盘IO与预读*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-2-B-%E6%A0%91"><span class="nav-number">1.7.2.</span> <span class="nav-text">*3.7.2* *B+树*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-3-B-%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B"><span class="nav-number">1.7.3.</span> <span class="nav-text">*3.7.3 B**+树的查找过程*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-4-B-%E6%A0%91%E6%80%A7%E8%B4%A8"><span class="nav-number">1.7.4.</span> <span class="nav-text">3.7.4 B+树性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-5-%E8%81%9A%E7%84%A6%E7%B4%A2%E5%BC%95%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95"><span class="nav-number">1.7.5.</span> <span class="nav-text">*3.7.5* *聚焦索引和辅助索引*</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F-%E5%BF%85%E4%BC%9A"><span class="nav-number">1.8.</span> <span class="nav-text">*3.8* *数据库三范式**(必会)*</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-1-%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F-1st-NF-%EF%BC%8DFirst-Normal-Fromate"><span class="nav-number">1.8.1.</span> <span class="nav-text">*3.8.1* *第一范式(1st* *NF* *－First Normal Fromate)*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-2-%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F-2nd-NF%EF%BC%8DSecond-Normal-Fromate"><span class="nav-number">1.8.2.</span> <span class="nav-text">*3.8.2* *第二范式(2nd* *NF－Second Normal Fromate)*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-3-%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F-3rd-NF-%EF%BC%8D-Third-Normal-Fromate"><span class="nav-number">1.8.3.</span> <span class="nav-text">*3.8.3* *第三范式(3rd* *NF**－* *Third Normal Fromate)*</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-9-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1-%E5%BF%85%E4%BC%9A"><span class="nav-number">1.9.</span> <span class="nav-text">*3.9* *数据库事务**(必会)*</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-1-%E4%BA%8B%E5%8A%A1-TRANSACTION"><span class="nav-number">1.9.1.</span> <span class="nav-text">*3.9.1* *事务(TRANSACTION)*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-2-%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.9.2.</span> <span class="nav-text">3.9.2 事务控制语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-3-MySQL-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E4%B8%BB%E8%A6%81%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">1.9.3.</span> <span class="nav-text">*3.9.3* *MySQL 事务处理主要有两种方法：*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-4-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.9.4.</span> <span class="nav-text">*3.9.4* *事务的四种隔离级别*</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-10-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-%EF%BC%88%E9%AB%98%E8%96%AA%E5%B8%B8%E9%97%AE%EF%BC%89"><span class="nav-number">1.10.</span> <span class="nav-text">*3.10* *存储过程**（高薪常问）*</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-11-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E7%AD%96%E7%95%A5-%EF%BC%88%E9%AB%98%E8%96%AA%E5%B8%B8%E9%97%AE%EF%BC%89"><span class="nav-number">1.11.</span> <span class="nav-text">*3.11* *数据库并发策略**（高薪常问）*</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-1-%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-number">1.11.1.</span> <span class="nav-text">*3.1**1**.1 乐观锁*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-11-2-%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">1.11.2.</span> <span class="nav-text">*3.11.2* *悲观锁*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-11-3-%E4%B8%A4%E7%A7%8D%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.11.3.</span> <span class="nav-text">*3.11.3* *两种锁的使用场景*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-11-4-%E4%B9%90%E8%A7%82%E9%94%81%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%BC%8F%E7%89%88%E6%9C%AC%E5%8F%B7%E6%9C%BA%E5%88%B6"><span class="nav-number">1.11.4.</span> <span class="nav-text">3.11.4 乐观锁常见的两种实现式版本号机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-11-5-%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">1.11.5.</span> <span class="nav-text">*3.11.5* *乐观锁的缺点*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-11-6-%E6%97%B6%E9%97%B4%E6%88%B3"><span class="nav-number">1.11.6.</span> <span class="nav-text">*3.11.6* *时间戳*</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-12-%E8%A7%A6%E5%8F%91%E5%99%A8-%EF%BC%88%E9%AB%98%E8%96%AA%E5%B8%B8%E9%97%AE%EF%BC%89"><span class="nav-number">1.12.</span> <span class="nav-text">*3.12* *触发器**（高薪常问）*</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-13-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81-%EF%BC%88%E9%AB%98%E8%96%AA%E5%B8%B8%E9%97%AE%EF%BC%89"><span class="nav-number">1.13.</span> <span class="nav-text">*3.13* *数据库锁**（高薪常问）*</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-13-1-%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="nav-number">1.13.1.</span> <span class="nav-text">*3.13.1* *行级锁*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-13-2-%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="nav-number">1.13.2.</span> <span class="nav-text">*3.13.2* *表级锁*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-13-3-%E9%A1%B5%E7%BA%A7%E9%94%81"><span class="nav-number">1.13.3.</span> <span class="nav-text">*3.13.3* *页级锁*</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-14-%E5%9F%BA%E4%BA%8E-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%EF%BC%88%E9%AB%98%E8%96%AA%E5%B8%B8%E9%97%AE%EF%BC%89"><span class="nav-number">1.14.</span> <span class="nav-text">*3.14* *基于* *Redis* *分布式锁**（高薪常问）*</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-15-%E5%88%86%E5%8C%BA%E5%88%86%E8%A1%A8-%EF%BC%88%E9%AB%98%E8%96%AA%E5%B8%B8%E9%97%AE%EF%BC%89"><span class="nav-number">1.15.</span> <span class="nav-text">*3.15* *分区分表**（高薪常问）*</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-16-%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%AE%9E%E6%96%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%8C%E8%BF%99%E8%A6%81%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E7%93%B6%E9%A2%88%E6%89%80%E5%9C%A8%EF%BC%8C%E5%B9%B6%E7%BB%BC%E5%90%88%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%9A%E5%8A%A1%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E8%80%83%E8%99%91%E3%80%82-%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">1.16.</span> <span class="nav-text">*3.16* *应该使用哪一种方式来实施数据库分库分表，这要看数据库中数据量的瓶颈所在，并综合项目的业务类型进行考虑。**（了解）*</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-17-MySQL-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB-%EF%BC%88%E9%AB%98%E8%96%AA%E5%B8%B8%E9%97%AE%EF%BC%89"><span class="nav-number">1.17.</span> <span class="nav-text">*3.17* *MySQL* *读写分离**（高薪常问）*</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-18-MySQL-%E5%B8%B8%E7%94%A8-30-%E7%A7%8D-SQL-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95-%E5%BF%85%E4%BC%9A"><span class="nav-number">1.18.</span> <span class="nav-text">*3.18* *MySQL* *常用* *30* *种* *SQL* *查询语句优化方法**(必会)*</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="毋  豆"
      src="/images/touxiang.gif">
  <p class="site-author-name" itemprop="name">毋  豆</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wudou" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wudou" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:760237638@qq.com" title="Mail → mailto:760237638@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">毋  豆</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
