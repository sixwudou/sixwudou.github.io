<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-circle.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sixwudou.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="重载和重写的区别（了解）重载： 发生在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。  重写： 发生在父子类中，方法名，参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。  String和StringBuffer,Strin">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础">
<meta property="og:url" content="https://sixwudou.github.io/2022/02/10/java%E9%9D%A2%E7%BB%8F/index.html">
<meta property="og:site_name" content="毋  豆 Blog">
<meta property="og:description" content="重载和重写的区别（了解）重载： 发生在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。  重写： 发生在父子类中，方法名，参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。  String和StringBuffer,Strin">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88B7.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88B8.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88B9.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88BA.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88BB.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88BC.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88BD.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88BE.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88CF.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88D0.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88D1.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88D2.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88D3.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88D4.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88D5.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88D6.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88D7.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88D8.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88E8.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88E9.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88EA.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88EB.tmp.jpg">
<meta property="og:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88EC.tmp.jpg">
<meta property="article:published_time" content="2022-02-10T06:26:32.000Z">
<meta property="article:modified_time" content="2022-02-10T06:36:30.159Z">
<meta property="article:author" content="毋  豆">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="file:///C:/Users/76023/AppData/Local/Temp/ksohtml/wps88B7.tmp.jpg">

<link rel="canonical" href="https://sixwudou.github.io/2022/02/10/java%E9%9D%A2%E7%BB%8F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>java基础 | 毋  豆 Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
	<a target="_blank" rel="noopener" href="https://github.com/sixwudou" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">毋  豆 Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sixwudou.github.io/2022/02/10/java%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.gif">
      <meta itemprop="name" content="毋  豆">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="毋  豆 Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-10 14:26:32 / 修改时间：14:36:30" itemprop="dateCreated datePublished" datetime="2022-02-10T14:26:32+08:00">2022-02-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="重载和重写的区别（了解）"><a href="#重载和重写的区别（了解）" class="headerlink" title="重载和重写的区别（了解）"></a>重载和重写的区别（了解）</h3><p><strong>重载</strong>： 发生在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 </p>
<p><strong>重写：</strong> 发生在父子类中，方法名，参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。 </p>
<h3 id="String和StringBuffer-StringBuilder-的区别是什么？String-为什么是不可变的？（必会）"><a href="#String和StringBuffer-StringBuilder-的区别是什么？String-为什么是不可变的？（必会）" class="headerlink" title="String和StringBuffer,StringBuilder 的区别是什么？String 为什么是不可变的？（必会）"></a>String和StringBuffer,StringBuilder 的区别是什么？String 为什么是不可变的？（必会）</h3><p><strong>可变性</strong> </p>
<p>简单的来说：String 类中使用 final 关键字字符数组保存字符串， private final char value[] ，所以 String对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在AbstractStringBuilder中也是使用字符数组保存字符串 char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。 </p>
<p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。 </p>
<p>AbstractStringBuilder.java</p>
<p>abstract class AbstractStringBuilder implements Appendable, CharSequence { </p>
<p>char[] value; </p>
<p>int count; </p>
<p>AbstractStringBuilder() { </p>
<p>}</p>
<p>AbstractStringBuilder(int capacity) { </p>
<p>value = new char[capacity]; </p>
<p>}</p>
<p><strong>线程安全性</strong> </p>
<p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity.append.insert.indexOf 等公共 方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 </p>
<p><strong>性能</strong> </p>
<p>abstract class AbstractStringBuilder implements Appendable, CharSequence { </p>
<p>char[] value; </p>
<p>int count; </p>
<p>AbstractStringBuilder() { </p>
<p>}</p>
<p>AbstractStringBuilder(int capacity) { </p>
<p>value = new char[capacity]; </p>
<p>}</p>
<p>}</p>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。 </p>
<p>StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 </p>
<p><em><strong>*对于三者使用的总结：*</strong></em> </p>
<p>\1. 操作少量的数据 =&gt; 使用String </p>
<p>\2. 单线程操作字符串缓冲区下操作大量数据 =&gt; 使用StringBuilder </p>
<p>\3. 多线程操作字符串缓冲区下操作大量数据 =&gt; 使用StringBuffer </p>
<h3 id="自动装箱与拆箱-了解"><a href="#自动装箱与拆箱-了解" class="headerlink" title="自动装箱与拆箱*****(了解)*"></a>自动装箱与拆箱****<em><strong>*(了解)*</strong></em></h3><p>****装箱：****将基本类型用它们对应的引用类型包装起来； </p>
<p>****拆箱：****将包装类型转换为基本数据类型； </p>
<h3 id="与-equals-必会"><a href="#与-equals-必会" class="headerlink" title="== 与 equals(必会)"></a>== 与 equals(必会)</h3><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即: 判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。</p>
<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况,如下： </p>
<p>****情况1****：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。 </p>
<p>****情况2****：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 </p>
<p>public class test1 { </p>
<p>public static void main(String[] args) { </p>
<p>String a = new String(“ab”); // a 为一个引用 </p>
<p>String b = new String(“ab”); // b为另一个引用,对象的内容一样 </p>
<p>String aa = “ab”; // 放在常量池中 </p>
<p>String bb = “ab”; // 从常量池中查找 </p>
<p>if (aa == bb) // true </p>
<p>System.out.println(“aa==bb”); </p>
<p>if (a == b) // false，非同一对象 </p>
<p>System.out.println(“a==b”); </p>
<p>if (a.equals(b)) // true </p>
<p>System.out.println(“aEQb”); </p>
<p>if (42 == 42.0) // true </p>
<p>System.out.println(“true”); </p>
<p>} </p>
<p>}</p>
<p><em><strong>*说明：*</strong></em> </p>
<p>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的equals 方法比较的是对象的值。 </p>
<p>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</p>
<h3 id="关于final关键字的一些总结-必会"><a href="#关于final关键字的一些总结-必会" class="headerlink" title="关于final关键字的一些总结(必会)"></a>关于final关键字的一些总结(必会)</h3><p><em><strong>*final关键字主要用在三个地方：变量、方法、类。*</strong></em> </p>
<p>\1. 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 </p>
<p>\2. 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。 </p>
<p>\3. 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。 </p>
<p>在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。 </p>
<h3 id="Java-中的异常处理-了解"><a href="#Java-中的异常处理-了解" class="headerlink" title="Java 中的异常处理(了解)"></a>Java 中的异常处理(了解)</h3><p>在 Java 中，所有的异常都有一个共同的祖先java.lang包中的<strong>Throwable类</strong>。</p>
<p><em><strong>*Throwable：*</strong></em> 有两个重要的子类： <img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88B7.tmp.jpg" alt="img"></p>
<p><strong>Exception（异常）</strong> 和 <strong>Error（错误）</strong>，二者都是 Java 异常处理的重要子类，各自都包含大量子类。 </p>
<h3 id="error-和-exception-的区别-了解"><a href="#error-和-exception-的区别-了解" class="headerlink" title="error 和 exception 的区别?(了解)"></a>error 和 exception 的区别?(了解)</h3><p>Error 类和 Exception 类的父类都是 Throwable 类，他们的区别如下。 </p>
<p>Error 类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢出等。对于这类 错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。 </p>
<p>Exception 类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。 </p>
<p>Exception 类又分为运行时异常(Runtime Exception)和受检查的异常(CheckedException )，运行时异常。</p>
<h3 id="接口和抽象类的区别是什么-必会"><a href="#接口和抽象类的区别是什么-必会" class="headerlink" title="接口和抽象类的区别是什么(必会)"></a>接口和抽象类的区别是什么(必会)</h3><p>\1. 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），抽象类可以有非抽象的方法。 </p>
<p>\2. 接口中的实例变量默认是 final 类型的，而抽象类中则不一定。 </p>
<p>\3. 一个类可以实现多个接口，但最多只能实现一个抽象类。 </p>
<p>\4. 一个类实现接口的话要实现接口的所有方法，而抽象类不一定。 </p>
<p>\5. 接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。 </p>
<p>备注: 在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，必须重写，不然会报错。</p>
<h3 id="什么是单例模式？有几种？-必会"><a href="#什么是单例模式？有几种？-必会" class="headerlink" title="什么是单例模式？有几种？(必会)"></a>什么是单例模式？有几种？(必会)</h3><p>单例模式：某个类的实例在 多线程环境下只会被创建一次出来。</p>
<p>  单例模式有饿汉式单例模式、懒汉式单例模式和双检锁单例模式三种。</p>
<p>  ****饿汉式****：线程安全，一开始就初始化。</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88B8.tmp.jpg" alt="img"> </p>
<p>  ****懒汉式****：非线程安全，延迟初始化。</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88B9.tmp.jpg" alt="img"> </p>
<p>****双检锁****：线程安全，延迟初始化。</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88BA.tmp.jpg" alt="img"> </p>
<h3 id="手写冒泡排序？-必会"><a href="#手写冒泡排序？-必会" class="headerlink" title="手写冒泡排序？(必会)"></a>手写冒泡排序？(必会)</h3><p>public class Sort {</p>
<p>​    public static void sort() {</p>
<p>​        Scanner input = new Scanner(System.in);</p>
<p>​        int sort[] = new int[10];</p>
<p>​        int temp;</p>
<p>​        System.out.println(“请输入10个排序的数据：”);</p>
<p>​        for (int i = 0; i &lt; sort.length; i++) {</p>
<p>​            sort[i] = input.nextInt();</p>
<p>​        }</p>
<p>​        for (int i = 0; i &lt; sort.length - 1; i++) {</p>
<p>​            for (int j = 0; j &lt; sort.length - i - 1; j++)             {</p>
<p>​                if (sort[j] &lt; sort[j + 1]) {</p>
<p>​                    temp = sort[j];</p>
<p>​                    sort[j] = sort[j + 1];</p>
<p>​                    sort[j + 1] = temp;</p>
<p>​                }</p>
<p>​            }</p>
<p>​        }</p>
<p>​        System.out.println(“排列后的顺序为：”);</p>
<p>​        for(int i=0;i&lt;sort.length;i++){</p>
<p>​            System.out.print(sort[i]+”======”);</p>
<p>​        }</p>
<p>​    }</p>
<p>​    public static void main(String[] args) {</p>
<p>​        sort();</p>
<p>​    }</p>
<p>}</p>
<h3 id="BIO、NIO、AIO-有什么区别？-了解"><a href="#BIO、NIO、AIO-有什么区别？-了解" class="headerlink" title="BIO、NIO、AIO 有什么区别？(了解)"></a>BIO、NIO、AIO 有什么区别？(了解)</h3><p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。 </p>
<p>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。 </p>
<p>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p>
<h3 id="常见的数据结构有哪些？-了解"><a href="#常见的数据结构有哪些？-了解" class="headerlink" title="常见的数据结构有哪些？(了解)"></a>常见的数据结构有哪些？(了解)</h3><p>l 数组：</p>
<p><strong>**数组*<em><strong>是最常用的数据结构，数组的特点是</strong>长度固定</em>*，</strong>可以用下标索引<strong>，</strong>并且所有的元素的类型都是一致的**。数组常用的场景有：从数据库里读取雇员的信息存储为EmployeeDetail[ ];把一个字符串转换并存储到一个字节数组中便于操作和处理等等。尽量把数组封装在一个类里，防止数据被错误的操作弄乱。另外，这一点也适合其他的数据结构。</p>
<p>l 列表：</p>
<p><strong>**列表*<em><strong>和数组很相似，只不过它的</strong>大小可以改变</em>*。</strong>列表<strong>一般都是</strong>通过一个固定大小的数组<strong>来</strong>实现<strong>的，并且</strong>会<strong>在需要的时候</strong>自动调整大小<strong>。列表里</strong>可以包含重复的元素**。常用的场景有，添加一行新的项到订单列表里，把所有过期的商品移出商品列表等等。一般会把列表初始化成一个合适的大小，以减少调整大小的次数。</p>
<p>l 集合：</p>
<p>****集合*<em><strong>和列表很相似，不过它</strong>不能放重复的元素。</em>*</p>
<p>l 堆栈：</p>
<p><strong>**堆栈*<em><strong>只允许</strong>对最后插入</em>*的</strong>元素进行操作<strong>（也就是</strong>后进先出<strong>，Last In First Out – LIFO）。如果你移除了栈顶的元素，那么你可以操作倒数第二个元素，依次类推。这种后进先出的方式是通过仅有的</strong>peek(),push()和pop()<strong>这几个方法的</strong>强制性**限制达到的。</p>
<p>l 队列：</p>
<p><strong>**队列*<em><strong>和堆栈有些相似，不同之处在于在队列里</strong>第一个插入的元素也是第一个被删除的元素</em>*（即是</strong>先进先出**）。这种先进先出的结构是通过只提供peek()，offer()和poll()这几个方法来访问数据进行限制来达到的。例如，排队等待公交车，银行或者超市里的等待列队等等，都是可以用队列来表示。</p>
<p>l 链表：</p>
<p>链表是一种由****多个节点组成的****数据结构，并且每个节点包含有数据以及指向下一个节点的引用，在双向链表里，还会有一个指向前一个节点的引用。例如，可以用单向链表和双向链表来实现堆栈和队列，因为链表的两端都是可以进行插入和删除的动作的。当然，也会有在链表的中间频繁插入和删除节点的场景。Apache的类库里提供了一个TreeList的实现，它是链表的一个很好的替代，因为它只多占用了一点内存，但是性能比链表好很多。也就是说，从这点来看链表其实不是一个很好的选择。</p>
<h3 id="Java集合体系有什么-必会"><a href="#Java集合体系有什么-必会" class="headerlink" title="Java集合体系有什么?(必会)"></a>Java集合体系有什么?(必会)</h3><p>集合类存放于 Java.util 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)。 </p>
<p>\1. Collection：Collection 是集合 List、Set、Queue 的最基本的接口。 </p>
<p>\2. Iterator：迭代器，可以通过迭代器遍历集合中的数据。 </p>
<p>\3. Map：是映射表的基础接口。</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88BB.tmp.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88BC.tmp.jpg" alt="img"><strong>1. Iterator接口</strong></p>
<p>Iterator接口是一个用于遍历集合中元素的接口，主要包含****hashNext(),next(),remove()*<em><strong>三种方法。如果实现Iterator接口，那么在遍历集合中元素的时候，只能往后遍历，被遍历后的元素不会在遍历到，通常</strong>无序集合实现的都是这个接口</em>*，比如HashSet，HashMap</p>
<p><strong>2. LinkedIterator接口：</strong></p>
<p>LinkedIterator在Iterator的基础上又添加了****add(),previous(),hasPrevious()*<em><strong>三种方法，那些元素</strong></em>*有序的集合*<em><strong>，实现的</strong></em>*一般都是LinkedIterator接口*<em><strong>，实现这个接口的集合可以双向遍历，既可以通过</strong></em>*next()访问下一个元素*<em><strong>，又可以通过</strong></em>*previous()访问前一个元素****，比如ArrayList。</p>
<p><strong>3.Collection （集合的最大接口）继承关系</strong></p>
<p>l List 可以存放重复的内容</p>
<p>l Set 不能存放重复的内容，所以的重复内容靠hashCode()和equals()两个方法区分</p>
<p>l Queue 队列接口</p>
<p>l SortedSet可以对集合中的数据进行排序</p>
<p>Collection定义了集合框架的共性功能：</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88BD.tmp.jpg" alt="img"> </p>
<p>add方法的参数类型是Object。以便于接收任意类型对象。</p>
<p><em><strong>*集合中存储的都是对象的引用(地址)。*</strong></em></p>
<p><em><strong>*4.List*</strong></em></p>
<p>凡是可以操作角标的方法都是该体系特有的方法：</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88BE.tmp.jpg" alt="img"> </p>
<p>l ArrayList 线程不安全，查询速度快</p>
<p>l Vector 线程安全，但速度慢，已被ArrayList替代</p>
<p>l LinkedList 链表结果，增删速度快</p>
<p>l TreeList 树型结构，保证增删复杂度都是O（log n）,增删性能远高于ArrayList和    LinkedList,但是稍微占用内存</p>
<p><strong>5.Set</strong> </p>
<p>l Set：元素是<em><strong>*无序*</strong></em>(存入和取出的顺序不一定一致)，元素****不可以重复****。</p>
<p>u HashSet:<em><strong>*底层*<em><strong>数据结构是</strong></em>*哈希表*</strong></em><em><strong>*,*</strong></em> 是****线程不安全****的, 数据不同步。</p>
<p>u HashSet是如何****保证元素唯一性****的呢？</p>
<p>是通过元素的两个方法，****hashCode和equals****来完成。</p>
<p>如果元素的HashCode值相同，才会判断equals是否为true。</p>
<p>如果元素的hashcode值不同，不会调用equals。</p>
<p>注意,对于判断元素是否存在，以及删除等操作，依赖的方法是元素的    hashcode和equals方法。</p>
<p>l TreeSet：****底层*<em><strong>数据结构是</strong></em>*二叉树*<em><strong>，存放</strong></em>*有序*<em><strong>：TreeSet</strong></em>*线程不安全****可以对Set集合中的元素进行排序。通过compareTo或者compare方法来保证元素的唯一性。</p>
<p><strong>6.Map</strong> </p>
<p>Correction、Set、List接口都属于单值的操作，而Map中的每个元素都使用key——&gt;value的形式存储在集合中。</p>
<p>Map集合：该集合存储键值对, 是key:value一对一对往里存, 而且要保证键的唯一性。</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88CF.tmp.jpg" alt="img"> </p>
<p>Map接口的常用子类</p>
<p>l HashMap：****底层*<em><strong>数据结构是</strong></em>*哈希表****，允许使用 null 值和 null 键，该集合是数据不同步的，将hashtable替代，jdk1.2.效率高。</p>
<p>l TreeMap：<em><strong>*底层*<em><strong>数据结构是</strong></em>*二叉树*</strong></em>****，****线程不同步，可以用于给map集合中的键进行排序。</p>
<h3 id="List-的三个子类的特点-必会"><a href="#List-的三个子类的特点-必会" class="headerlink" title="List 的三个子类的特点(必会)"></a>List 的三个子类的特点(必会)</h3><p>ArrayList 底层结构是数组,底层查询快,增删慢 </p>
<p>LinkedList 底层结构是链表型的,增删快,查询慢 </p>
<p>Voctor 底层结构是数组 线程安全的,增删慢,查询慢</p>
<h3 id="List-和-Map、Set-的区别-必会"><a href="#List-和-Map、Set-的区别-必会" class="headerlink" title="List 和 Map、Set 的区别(必会)"></a>List 和 Map、Set 的区别(必会)</h3><p><strong>结构特点:</strong></p>
<p>List 和 Set 是存储单列数据的集合，Map 是存储键和值这样的双列数据的集合；</p>
<p>List 中存储的数据是有顺序，并且允许重复；</p>
<p>Map 中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的，Set中存储的数据是无序的，且不允许有重复，但元素在集合中的位置由元素的 hashcode 决定，位置是固定的（Set 集合根据 hashcode 来进行数据的存储，所以位置是固定的，但是位置不是用户可以控制的，所以对于用户来说 set 中的元素还是无序的）； </p>
<p><strong>实现类</strong> </p>
<p><strong>**List 接口*<em><strong>有三个实现类（</strong>LinkedList</em>*：基于链表实现，链表内存是散乱的，每一个元素存储本身内存地址的同时还存储下一个元素的地址。链表增删快，查找慢；</strong>ArrayList<strong>：基于数组实现，非线程安全的，效率高，便于索引，但不便于插入删除；</strong>Vector**：基于数组实现，线程安全的，效率低）。 </p>
<p><strong>**Map 接口*<em><strong>有三个实现类（</strong>HashMap</em>*：基于 hash 表的 Map 接口实现，非线程安全，高效，支持 null 值和 null键；</strong>HashTable<strong>：线程安全，低效，不支持 null 值和 null 键；</strong>LinkedHashMap**：是 HashMap 的一个子类，保存了记录的插入顺序；SortMap 接口：TreeMap，能够把它保存的记录根据键排序，默认是键值的升序排序）。 </p>
<p>****Set 接口*<em><strong>有两个实现类（</strong>HashSet</em>*：底层是由 HashMap 实现，不允许集合中有重复的值，使用该方式时需要重写 equals()和 hashCode()方法；LinkedHashSet：继承与 HashSet，同时又基于 LinkedHashMap 来进行实现，底层使用的是 LinkedHashMp）。</p>
<h3 id="1-16-HashMap底层实现原理-必会"><a href="#1-16-HashMap底层实现原理-必会" class="headerlink" title="1.16 HashMap底层实现原理(必会)"></a>1.16 HashMap底层实现原理(必会)</h3><p>HashMap根据键的hashCode值存储数据,大多数情况下可以直接定位到它的值.因而具有很快的访问速度,但是遍历顺序却不确定的.HashMap最多只允许一条记录的键为null,允许多条记录的值为null。</p>
<p>HashMap非线程安全,即任一时刻可以有多个线程同时写HashMap,可能会导致数据的不一致。</p>
<p>如果需要满足线程安全,可以用Collections的synchronizedMap方法使HashMap具有线程安全的能力,或者使用ConcurrentHashMap,HashTable.如下详细介绍。</p>
<p><strong>l</strong> <em><strong>*JDK1.8之前 (数组+链表)*</strong></em></p>
<p><strong>n</strong> <em><strong>*最开始存入数据的时候*</strong></em></p>
<p>\1. JDK1.8之前HashMap底层是数组和链表结合在一起使用,也就是链表散列.数组的长度规定是2的幂.数组中存放的对象是Entry&lt;key,value&gt;对象 ,不允许有重复的key存在,为什么呢?</p>
<p>\2. 首先,先判断key存放的位置, HashMap通过key的hashCode经过扰动函数处理过后得到hash值,然后通过(n-1)&amp;hash判断当前元素存放的位置(这里的n指的是数组的长度). 也可以理解:key%数组长度=对应数组的索引下标.然后将value存入到entry对象中。</p>
<p>所谓扰动函数知道就是HashMap的hash方法.使用hash方法也就是扰动函数是为了防止一些实现比较差的hashCode()方法,换句话说使用扰动函数之后可以减少碰撞。</p>
<p>\3. 为什么使用(n-1)&amp;length长度呢?</p>
<p>(1)保证数组不会越界:</p>
<p>首先我们要知道,在HashMap和ConcurrentHashMap中,数组的长度按规定一定是2的幂(2的n次方)因此,数组的长度的二进制形式是:10000…000,1后面有一堆0。那么tab.length - 1 的二进制形式就是01111…111，0后面有一堆1。最高位是0, 和hash值相”与”，结果值一定不会比数组的长度值大,因此也就不会发生数组越界.</p>
<p>(2)保证元素尽可能的均匀分布</p>
<p>在操作的时候,链表中的元素越多,效率越低,因为要不停的对链表循环比较.所以,一定要使哈希均匀分布,尽量减少哈希冲突,提高效率。</p>
<p><strong>n</strong> <em><strong>*继续存入数据*</strong></em></p>
<p>继续存入数据,还是要通过第1步计算key在数组中的索引位置. 如果当前位置存在元素的话,再通过key的equal()方法判断key是否相同,如果相同value值就会覆盖; 如果key的equals()方法不同,则在数组对应索引位置变为链表存储新的Entry&lt;key,value&gt;。</p>
<p><strong>n</strong> <em><strong>*拉链法*</strong></em></p>
<p>上一步说到的链表是拉链法: 将链表和数组相结合.也就是说创建一个链表数组,数组中每一格就是一个链表.若约到哈希冲突,则将冲突的值加到链表中即可.</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88D0.tmp.jpg" alt="img"> </p>
<p><strong>l</strong> <em><strong>*JDK1.8之后(数组+链表+红黑树)*</strong></em></p>
<p>如果链表的长度超过8则转为红黑树, 当红黑树中的元素小于6时又变为链表(有这些变化的原因就是综合时间复杂度以及空间复杂度的考虑)获取时,直接找到key的hash值对应的下标,在进一步用equels方法判断key是否相同,从而找到对应值则返回找不到则返回null。</p>
<p>相比于之前的版本,jdk1.8在解决哈希冲突时有了较大的变化,当链表长度大于阀值(默认为8)时,将链表转化为红黑树,以减少搜索时间。</p>
<p>​    <img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88D1.tmp.jpg" alt="img"></p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88D2.tmp.jpg" alt="img"> </p>
<h3 id="1-17谈一下-hashMap-中什么时候需要进行扩容，扩容-resize-又是如何实现的？-高薪常问"><a href="#1-17谈一下-hashMap-中什么时候需要进行扩容，扩容-resize-又是如何实现的？-高薪常问" class="headerlink" title="1.17谈一下 hashMap 中什么时候需要进行扩容，扩容 resize()又是如何实现的？(高薪常问)"></a>1.17谈一下 hashMap 中什么时候需要进行扩容，扩容 resize()又是如何实现的？(高薪常问)</h3><p><em><strong>*调用场景：*</strong></em> </p>
<p>\1. 初始化数组 table </p>
<p>\2. 当数组 table 的 size 达到阙值时进行扩容 </p>
<p><em><strong>*实现过程：*</strong></em> </p>
<p>通过判断旧数组的容量是否大于0来判断数组是否初始化过。</p>
<p>l 如果小于0：进行初始化,判断是否调用无参构造器。</p>
<p>如果调用了无参构造器: 使用默认的大小和阙值&lt;阈值 12. 阀值=默认    大小为16乘以负载因子0.75。</p>
<p>如果没有调用无参构造器: 使用构造函数中初始化的容量, 当然这个容    量是经过tableSizefor 计算后的 2 的次幂数) 。</p>
<p>l 如果大于0: 进行扩容，扩容成两倍(小于最大值的情况下)，之后在进行将元素重新进行与运算复制到新的散列表中。</p>
<p><em><strong>*概括的讲：*</strong></em></p>
<p>扩容需要重新分配一个新数组，新数组是老数组的2倍长，然后遍历整个老结<strong>构，</strong>把所有的元素挨个重新hash分配到新结构中去。PS：可见底层数据结构用到了数组，到最后会因为容量问题都需要进行扩容操作。</p>
<h3 id="ConcurrentHashMap特点-高薪常问"><a href="#ConcurrentHashMap特点-高薪常问" class="headerlink" title="ConcurrentHashMap特点(高薪常问)"></a>ConcurrentHashMap特点(高薪常问)</h3><p><strong>Segment 段</strong> </p>
<p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分”或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个segment。  </p>
<p><strong>线程安全（Segment 继承 ReentrantLock 加锁）</strong> </p>
<p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个Segment 是线程安全的，也就实现了全局的线程安全。</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88D3.tmp.jpg" alt="img"> </p>
<p><strong>并行度（默认 16）</strong> </p>
<p>concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。 </p>
<p><strong>Java8 实现 （引入了红黑树）</strong> </p>
<p>Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88D4.tmp.jpg" alt="img"> </p>
<h3 id="HashTable-了解"><a href="#HashTable-了解" class="headerlink" title="HashTable(了解)"></a>HashTable(了解)</h3><p>Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。</p>
<h3 id="HashMap-和-HashTable-有什么区别-必会"><a href="#HashMap-和-HashTable-有什么区别-必会" class="headerlink" title="HashMap 和 HashTable 有什么区别?(必会)"></a>HashMap 和 HashTable 有什么区别?(必会)</h3><p>HashMap 是线程不安全的,是 Map 的一个实现类,是将键映射到值得对象,不允许键值重复,允许空键和空值;由于非线程安全,HashMap 的效率要较 HashTable 的效率高一些. </p>
<p>HashTable 是线程安全的一个集合,不允许 null 值作为一个 key 值或者 Value 值; </p>
<p>HashTable 是 sychronize,多个线程访问时不需要自己为它的方法实现同步,而 HashMap 在被多个线程访问的时候需要自己为它的方法实现同步;</p>
<h3 id="HashMap，HashTable，ConcurrentHashMap之间的区别，及性能对比-必会"><a href="#HashMap，HashTable，ConcurrentHashMap之间的区别，及性能对比-必会" class="headerlink" title="HashMap，HashTable，ConcurrentHashMap之间的区别，及性能对比(必会)"></a>HashMap，HashTable，ConcurrentHashMap之间的区别，及性能对比(必会)</h3><p><em><strong>*性能：*<em><strong>ConcurrentHashMap(</strong></em>*线程安全*</strong></em>) &gt; HashMap &gt; HashTable(<em><strong>*线程安全*</strong></em>)</p>
<p><em><strong>*区别对比一(HashMap和HashTable区别)：*</strong></em></p>
<p>1、HashMap是非线程安全的，HashTable是线程安全的。</p>
<p>2、HashMap的键和值都允许有null值存在，而HashTable则不行。</p>
<p>3、因为线程安全的问题，HashMap效率比HashTable的要高。</p>
<p>4、Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。一般现在不建议用HashTable, ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。</p>
<p><em><strong>*区别对比二(HashTable和ConcurrentHashMap区别)：*</strong></em></p>
<p>****HashTable*<em><strong>使用的是Synchronized关键字修饰，</strong></em>*ConcurrentHashMap****是使用了锁分段技术来保证线程安全的。</p>
<p>****Hashtable*<em><strong>中采用的锁机制是一次锁住整个hash表，从而在同一时刻只能由一个线程对其进行操作；而</strong></em>*ConcurrentHashMap****中则是一次锁住一个桶。</p>
<p>ConcurrentHashMap默认将hash表分为16个桶，诸如get、put、remove等常用操作只锁住当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有16个写线程执行，并发性能的提升是显而易见的。</p>
<h3 id="什么是线程-线程和进程的区别-必会"><a href="#什么是线程-线程和进程的区别-必会" class="headerlink" title="什么是线程?线程和进程的区别?(必会)"></a>什么是线程?线程和进程的区别?(必会)</h3><p>****线程：****是进程的一个实体，是 cpu 调度和分派的基本单位，是比进程更小的可以独立运行的基本单位。</p>
<p>****进程：****具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位。 </p>
<p>****特点：****线程的划分尺度小于进程，这使多线程程序拥有高并发性，进程在运行时各自内存单元相互独立，线程之间 内存共享，这使多线程编程可以拥有更好的性能和用户体验。</p>
<p>****注意****：多线程编程对于其它程序是不友好的，占据大量 cpu 资源。 </p>
<h3 id="创建线程有几种方式-必会"><a href="#创建线程有几种方式-必会" class="headerlink" title="创建线程有几种方式(必会)"></a>创建线程有几种方式(必会)</h3><p><em><strong>*1.继承 Thread 类*</strong></em> </p>
<p>Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start()实例方法。****start()方法是一个 native 方法****，它将启动一个新线程，并执行 run()方法。</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88D5.tmp.jpg" alt="img"> </p>
<p><em><strong>*2.实现Runnable接口*</strong></em></p>
<p>如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现</p>
<p>一个 Runnable 接口。 </p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88D6.tmp.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88D7.tmp.jpg" alt="img"> </p>
<p><em><strong>*3.实现Callable接口*</strong></em></p>
<p>Callabled接口有点儿像是Runnable接口的增强版，它****以call()方法作为线程执行体****，    call()方法比run()方法功能更强大。</p>
<p>****call()方法可以有返回值，可以声明抛出异常类****。</p>
<p>获取call()方法里的返回值: 通过FutureTask类（实现Future接口）的实例对象的get()方法得到，得到结果类型与创建TutureTask类给的泛型一致。</p>
<p><em><strong>*具体代码实现*</strong></em></p>
<p><em><strong>*1*</strong></em><em><strong>*.*</strong></em><em><strong>*定义实现Callable接口的实现类，并实现call()方法。注意：Callable有泛型限制，与返回值类型一致。这里是Integer*</strong></em></p>
<p>public class ThirdThread implements Callable<Integer>{//重写call()方法}</p>
<p><em><strong>*2*</strong></em><em><strong>*.*</strong></em><em><strong>*再创建Callable实现类的实例tt。*</strong></em></p>
<p>ThirdThread tt = new ThirdThread();</p>
<p><em><strong>*3.*</strong></em><em><strong>*使用FutureTask类包装Callable的实例tt。*</strong></em></p>
<p>FutureTask<Integer> task = new FutureTask<Integer>(tt);//注意：泛型限制与返回结果一致。</p>
<p><em><strong>*4.以FutureTask对象（task）作为Thread的target来创建线程，并启动。*</strong></em></p>
<p>new Thread(task, “线程”).start();</p>
<p><em><strong>*5.调用FutureTask对象（task）的get()方法获得返回值*</strong></em></p>
<p>Integer result = task.get();//会有异常</p>
<p><strong>4.</strong> <em><strong>*通过线程池方法*</strong></em></p>
<p>l 什么是线程池,如何使用?</p>
<p>线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用 new 线程而是直接去池中拿线程即可，节省了开辟子线程的时间，提高的代码执行效率。</p>
<p>在 JDK 的 java.util.concurrent.Executors 中提供了生成多种线程池的静态方法.</p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88D8.tmp.jpg" alt="img"> </p>
<p>然后调用他们的 execute 方法即可。</p>
<p><em><strong>*合理利用线程池能够带来三个好处。*</strong></em> </p>
<p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 </p>
<p>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
<p>第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控. </p>
<p>l 常用的线程池有哪些？</p>
<p>****newSingleThreadExecutor：****创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 </p>
<p>****newFixedThreadPool：****创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。 </p>
<p>****newCachedThreadPool：****创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。 </p>
<p>****newScheduledThreadPool：****创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。 </p>
<h3 id="线程的基本方法有什么-必会"><a href="#线程的基本方法有什么-必会" class="headerlink" title="线程的基本方法有什么?(必会)"></a>线程的基本方法有什么?(必会)</h3><p>线程相关的基本方法有 <em><strong>*wait，notify，notifyAll，sleep，join，yield*</strong></em> 等。</p>
<p><em><strong>*1.线程等待（wait）*</strong></em> </p>
<p>调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用 wait()方法后，****会释放对象的锁****。因此，wait 方法一般用在同步方法或同步代码块中。 </p>
<p><em><strong>*2.线程睡眠（sleep）*</strong></em> </p>
<p><em><strong>*sleep 导致当前线程休眠，与 wait 方法不同的是*</strong></em> <em><strong>*sleep 不会释放当前占有的锁*</strong></em><em><strong>*,sleep(long)会导致线程进入*</strong></em> <em><strong>*TIMED-WATING*</strong></em> <em><strong>*状态，而*</strong></em> <em><strong>*wait()方法会导致当前线程进入 WATING*</strong></em> <em><strong>*状态.*</strong></em></p>
<p><em><strong>*3.线程让步（yield）*</strong></em> </p>
<p>yield 会使当前线程****让出 CPU 执行时间片****，与其他线程一起重新竞争 CPU 时间片。一般情况下， 优先级高的线程有更大的可能性成功竞争得到 CPU 时间片，但这又不是绝对的，有的操作系统对 线程优先级并不敏感。</p>
<p><em><strong>*4.线程中断（interrupt）*</strong></em> </p>
<p>中断一个线程，其本意是<em><strong>*给这个线程一个通知信号，会影响这个线程内部的一个中断标识位*</strong></em><em><strong>*。*</strong></em><em><strong>*这个线程本身并不会因此而改变状态(如阻塞，终止等)*</strong></em></p>
<p><em><strong>*5.Join 等待其他线程终止*</strong></em> </p>
<p>****join() 方法，等待其他线程终止****，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸.</p>
<p><em><strong>*6.线程唤醒（notify）*</strong></em> </p>
<p>Object 类中的 notify() 方法，****唤醒在此对象监视器上等待的单个线程*<em><strong>，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个 wait() 方法，在对象的监视器上等待，</strong></em>*直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程****，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程。</p>
<h3 id="在-java-中-wait-和-sleep-方法的不同？-必会"><a href="#在-java-中-wait-和-sleep-方法的不同？-必会" class="headerlink" title="在 java 中 wait 和 sleep 方法的不同？(必会)"></a>在 java 中 wait 和 sleep 方法的不同？(必会)</h3><p>最大的不同是在等待时 wait 会释放锁，而 sleep 一直持有锁。wait 通常被用于线程间交互，sleep 通常被用于暂停执行。 </p>
<h3 id="线程池原理-高薪常问"><a href="#线程池原理-高薪常问" class="headerlink" title="线程池原理(高薪常问)"></a>线程池原理(高薪常问)</h3><p>线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量<em><strong>*超出数量的线程排队等候*<em><strong>，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：</strong></em>*线程复用；控制最大并发数；管理线程*</strong></em><em><strong>*。*</strong></em> </p>
<p><em><strong>*线程复用:*</strong></em></p>
<p>每一个 Thread 的类都有一个 start 方法。 当调用 start 启动线程时 Java 虚拟机会调用该类的 run 方法。 那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。 ****我们可以继承重写 Thread 类，在其 start 方法中添加不断循环调用传递过来的 Runnable 对象*<em><strong>。 这就是线程池的实现原理。</strong></em>*循环方法中不断获取 Runnable 是用 Queue 实现的****，在获取下一个 Runnable 之前可以是阻塞的。</p>
<p><em><strong>*线程池的组成:*</strong></em></p>
<p>一般的线程池主要分为以下 4 个组成部分：</p>
<p>\1. 线程池管理器：用于创建并管理线程池 </p>
<p>\2. 工作线程：线程池中的线程 </p>
<p>\3. 任务接口：每个任务必须实现的接口，用于工作线程调度其运行 </p>
<p>\4. 任务队列：用于存放待处理的任务，提供一种缓冲机制</p>
<p><em><strong>*拒绝策略:*</strong></em> </p>
<p>线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。 </p>
<p>JDK 内置的拒绝策略如下： </p>
<p>\1. AbortPolicy ： 直接抛出异常，阻止系统正常运行。 </p>
<p>\2. CallerRunsPolicy ： 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。 </p>
<p>\3. DiscardOldestPolicy ： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。 </p>
<p>\4. DiscardPolicy ： 该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案</p>
<p><em><strong>*Java 线程池工作过程:*</strong></em> </p>
<p><img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88E8.tmp.jpg" alt="img"> </p>
<p>\1. 线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。 </p>
<p>\2. 当调用 execute() 方法添加一个任务时，线程池会做如下判断： </p>
<p>a) 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务； </p>
<p>b) 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列； </p>
<p>c) 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务； </p>
<p>d) 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常 RejectExecutionException。 </p>
<p>\3. 当一个线程完成任务时，它会从队列中取下一个任务来执行。 </p>
<p>\4. 当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p>
<h3 id="线程执行的顺序-高薪常问"><a href="#线程执行的顺序-高薪常问" class="headerlink" title="线程执行的顺序(高薪常问)"></a>线程执行的顺序(高薪常问)</h3><p>\1. 当线程数小于核心线程数时，会一直创建线程直到线程数等于核心线程数；</p>
<p>\2. 当线程数等于核心线程数时，新加入的任务会被放到任务队列等待执行；</p>
<p>\3. 当任务队列已满，又有新的任务时，会创建线程直到线程数量等于最大线程数；</p>
<p>\4. 当线程数等于最大线程数，且任务队列已满时，新加入任务会被拒绝。</p>
<h3 id="线程池的核心参数有哪些？-高薪常问"><a href="#线程池的核心参数有哪些？-高薪常问" class="headerlink" title="线程池的核心参数有哪些？(高薪常问)"></a>线程池的核心参数有哪些？(高薪常问)</h3><p><em><strong>*默认参数：*</strong></em></p>
<p>corePoolSize = 1</p>
<p>queueCapacity = Integer.MAX_VALUE</p>
<p>maxPoolSize = Integer.MAX_VALUE</p>
<p>keepAliveTime = 60秒</p>
<p>allowCoreThreadTimeout = false</p>
<p>rejectedExecutionHandler = AbortPolicy()</p>
<p><em><strong>*具体讲解：*</strong></em></p>
<p><em><strong>*1.corePoolSize（核心线程数）*</strong></em></p>
<p>（1）核心线程会一直存在，即使没有任务执行；</p>
<p>（2）当线程数小于核心线程数的时候，即使有空闲线程，也会一直创建线程直到达到核心线程数；</p>
<p>（3）设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭。</p>
<p><em><strong>*2.queueCapacity（任务队列容量）*</strong></em></p>
<p>也叫阻塞队列，当核心线程都在运行，此时再有任务进来，会进入任务队列，排队等待线程执行。</p>
<p><em><strong>*3.maxPoolSize（最大线程数）*</strong></em></p>
<p>（1）线程池里允许存在的最大线程数量；</p>
<p>（2）当任务队列已满，且线程数量大于等于核心线程数时，会创建新的线程执行任务；</p>
<p>（3）线程池里允许存在的最大线程数量。当任务队列已满，且线程数量大于等于核心线程数时，会创建新的线程执行任务。</p>
<p><em><strong>*4.keepAliveTime（线程空闲时间）*</strong></em></p>
<p>（1）当线程空闲时间达到keepAliveTime时，线程会退出（关闭），直到线程数等于核心线程数；</p>
<p>（2）如果设置了allowCoreThreadTimeout=true，则线程会退出直到线程数等于零。&lt;allowCoreThreadTimeout（允许核心线程超时）&gt;</p>
<p>当线程数量达到最大线程数，且任务队列已满时，会拒绝任务；</p>
<p>调用线程池shutdown()方法后，会等待执行完线程池的任务之后，再shutdown()。如果在调用了shutdown()方法和线程池真正shutdown()之间提交任务，会拒绝新任务。</p>
<h3 id="死锁产生的条件以及如何避免？-高薪常问"><a href="#死锁产生的条件以及如何避免？-高薪常问" class="headerlink" title="死锁产生的条件以及如何避免？(高薪常问)"></a>死锁产生的条件以及如何避免？(高薪常问)</h3><p><em><strong>*死锁产生的四个必要条件：*</strong></em></p>
<p>互斥：一个资源每次只能被一个进程使用（资源独立）。</p>
<p>请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放（不释放锁）。</p>
<p>不剥夺：进程已获得的资源，在未使用之前，不能强行剥夺（抢夺资源）。</p>
<p>循环等待：若干进程之间形成一种头尾相接的循环等待的资源关闭（死循环）。</p>
<p><em><strong>*避免死锁：*</strong></em></p>
<p>\1. 破坏”互斥”条件：系统里取消互斥、若资源一般不被一个进程独占使用，那么死锁是肯定不会发生的，但一般“互斥”条件是无法破坏的,因此，在死锁预防里主要是破坏其他三个必要条件，而不去涉及破坏“互斥”条件。</p>
<p>\2. 破坏“请求和保持”条件：</p>
<p>方法1：所有的进程在开始运行之前，必须一次性的申请其在整个运行过程各种所需要的全部资源。</p>
<p>优点：简单易实施且安全。</p>
<p>缺点：因为某项资源不满足，进程无法启动，而其他已经满足了的资源也不会得到利用，严重降低了资源的利用率，造成资源浪费。</p>
<p>方法2：该方法是对第一种方法的改进，允许进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到，已经使用完毕的资源，然后再去请求新的资源。这样的话资源的利用率会得到提高，也会减少进程的饥饿问题。</p>
<p>\3. 破坏“不剥夺”条件：当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。这就意味着进程已占有的资源会被短暂的释放或者说被抢占了。</p>
<p>\4. 破坏“循环等待”条件：可以通过定义资源类型的线性顺序来预防，可以将每个资源编号，当一个进程占有编号为i的资源时，那么它下一次申请资源只能申请编号大于i的资源。</p>
<h3 id="JVM是什么？JVM的基本结构-高薪常问"><a href="#JVM是什么？JVM的基本结构-高薪常问" class="headerlink" title="JVM是什么？JVM的基本结构 (高薪常问)"></a>JVM是什么？JVM的基本结构 (高薪常问)</h3><p>虚拟机，一种能够运行java字节码的虚拟机。</p>
<p>l 类加载子系统</p>
<p>l 加载 .class 文件到内存。</p>
<p>l 内存结构</p>
<p>l 运行时的数据区。</p>
<p>l 执行引擎</p>
<p>l 执行内存中的.class，输出执行结果（包含GC：垃圾收集器）。</p>
<p>l 本地方法的接口。</p>
<p>l 本地方法库。</p>
<p>​        <img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88E9.tmp.jpg" alt="img"></p>
<h3 id="JVM内存结构-高薪常问"><a href="#JVM内存结构-高薪常问" class="headerlink" title="JVM内存结构(高薪常问)"></a>JVM内存结构(高薪常问)</h3><p><em><strong>*JDK1.7*</strong></em></p>
<p>​            <img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88EA.tmp.jpg" alt="img"></p>
<p><em><strong>*程序计数器*</strong></em></p>
<p>就是一个指针，指向方法区中的方法字节码（用来存储指向下一个指令的地址，也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计。</p>
<p><em><strong>*Java虚拟机栈*</strong></em></p>
<p>Java线程执行方法的内存模型，一个线程对应一个栈，每个方法在执行的同时都会创建一个栈帧（用于存储局部变量表，操作数栈，动态链接，方法出口等信息）不存在垃圾回收问题，只要线程一结束该栈就释放，生命周期和线程一致。</p>
<p><em><strong>*本地方法栈*</strong></em></p>
<p>和栈作用很相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行native方法服务。登记native方法，在Execution Engine执行时加载本地方法库。</p>
<p><em><strong>*堆*</strong></em></p>
<p>Java虚拟机管理的最大的一块内存区域，Java堆是线程共享的，用于存放对象实例。也就是说对象的出生和回收都是在这个区域进行的。</p>
<p><em><strong>*方法区*</strong></em></p>
<p>线程共享，用于存储已经被虚拟机加载的类信息、常量、静态变量等数据。</p>
<p><em><strong>*JDK1.8*</strong></em></p>
<p>​            <img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88EB.tmp.jpg" alt="img"></p>
<p>JDK1.8与1.7最大的区别是在1.8中方法区是由元空间（元数据区）来实现。常量池移到堆中。</p>
<h3 id="类的加载，类加载器的种类-类加载机制-高薪常问"><a href="#类的加载，类加载器的种类-类加载机制-高薪常问" class="headerlink" title="类的加载，类加载器的种类,类加载机制(高薪常问)"></a>类的加载，类加载器的种类,类加载机制(高薪常问)</h3><p><strong>l</strong> <em><strong>*类加载*</strong></em></p>
<p>​    <img src="file:///C:\Users\76023\AppData\Local\Temp\ksohtml\wps88EC.tmp.jpg" alt="img"></p>
<p>1.加载</p>
<p>将.class文件从磁盘读到内存。</p>
<p>2.连接</p>
<p>2.1 验证: 验证字节码文件的正确性。</p>
<p>2.2 准备: 给类的静态变量分配内存，并赋予默认值。</p>
<p>2.3 解析: 类装载器装入类所引用的其它所有类。</p>
<p>3.初始化</p>
<p>为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序编写者为变量分配的真正的初始值，执行静态代码块。</p>
<p>4.使用</p>
<p>5.卸载</p>
<p><strong>l</strong> <em><strong>*类加载器的种类*</strong></em></p>
<p>\1. 启动类加载器(Bootstrap ClassLoader)</p>
<p>负责加载JRE的核心类库，如JRE目标下的rt.jar，charsets.jar等。</p>
<p>\2. 扩展类加载器(Extension ClassLoader)</p>
<p>负责加载JRE扩展目录ext中jar类包。</p>
<p>\3. 系统类加载器(Application ClassLoader)</p>
<p>负责加载ClassPath路径下的类包。</p>
<p>\4. 用户自定义加载器(User ClassLoader)</p>
<p>负责加载用户自定义路径下的类包。</p>
<p><strong>l</strong> <em><strong>*类加载机制*</strong></em></p>
<p>全盘负责委托机制</p>
<p>当A类中引用B类，那么除非特别指定B类的类加载器，否则就直接使用加载A类的类加载器加载B类。</p>
<p>双亲委派机制</p>
<p>指先委托父类加载器寻找目标类，在找不到的情况下再在自己的路径中查找并载入目标类。</p>
<h3 id="什么是GC-高薪常问"><a href="#什么是GC-高薪常问" class="headerlink" title="什么是GC(高薪常问)"></a>什么是GC(高薪常问)</h3><p>内存空间是有限的，那么在程序运行时如何及时的把不再使用的对象清除将内存释放出来，这就是GC要做的事。</p>
<p>l GC的区域在哪里？</p>
<p>JVM中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理。因此，我们的内存垃圾回收主要集中于 Java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的。</p>
<p>l GC的操作对象是什么？</p>
<p>需要进行回收的对象就是已经没有存活的对象，判断一个对象是否存活常用的有两种办法：引用计数和可达分析。</p>
<p>n 引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</p>
<p>n 可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p>
<p>在Java语言中，GC Roots包括：</p>
<p>n 虚拟机栈中引用的对象。</p>
<p>n 方法区中类静态属性实体引用的对象。</p>
<p>n 方法区中常量引用的对象。</p>
<p>n 本地方法栈中JNI引用的对象。</p>
<p>l GC的时机是什么？</p>
<p>(1)程序调用System.gc时可以触发。</p>
<p>(2)系统自身来决定GC触发的时机（根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程）。</p>
<p>l GC做了哪些事？</p>
<p>主要做了清理对象，整理内存的工作。</p>
<p>l GC常用算法</p>
<p>GC常用算法有：标记-清除算法，标记-压缩算法，复制算法，分代收集算法。目前主流的JVM（HotSpot）采用的是分代收集算法。</p>
<p><em><strong>*标记-清除算法*</strong></em></p>
<p>为每个对象存储一个标记位，记录对象的状态（活着或是死亡）。分为两个阶段，一个是标记阶段，这个阶段内，为每个对象更新标记位，检查对象是否死亡；第二个阶段是清除阶段，该阶段对死亡的对象进行清除，执行 GC 操作。</p>
<p><em><strong>*标记-压缩算法（标记-整理）*</strong></em></p>
<p>标记-压缩法是标记-清除法的一个改进版。同样，在标记阶段，该算法也将所有对象标记为存活和死亡两种状态；不同的是，在第二个阶段，该算法并没有直接对死亡的对象进行清理，而是将所有存活的对象整理一下，放到另一处空间，然后把剩下的所有对象全部清除。这样就达到了标记-整理的目的。</p>
<p><em><strong>*复制算法*</strong></em></p>
<p>该算法将内存平均分成两部分，然后每次只使用其中的一部分，当这部分内存满的时候，将内存中所有存活的对象复制到另一个内存中，然后将之前的内存清空，只使用这部分内存，循环下去。</p>
<p><em><strong>*分代收集算法*</strong></em></p>
<p>现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代(Young)和老年代(Tenure)。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。</p>
<h3 id="JVM调优的工具有哪些？-高薪常问"><a href="#JVM调优的工具有哪些？-高薪常问" class="headerlink" title="JVM调优的工具有哪些？(高薪常问)"></a>JVM调优的工具有哪些？(高薪常问)</h3><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>
<p>\1. jconsole：用于对 JVM 中的内存、线程和类等进行监控；</p>
<p>\2. jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</p>
<h3 id="常用的-JVM-调优的参数都有哪些？-高薪常问"><a href="#常用的-JVM-调优的参数都有哪些？-高薪常问" class="headerlink" title="常用的 JVM 调优的参数都有哪些？(高薪常问)"></a>常用的 JVM 调优的参数都有哪些？(高薪常问)</h3><p>XX比X的稳定性更差，并且版本更新不会进行通知和说明。</p>
<p>-Xms：s为strating，表示堆内存起始大小。</p>
<p>-Xmx：x为max，表示最大的堆内存（一般来说-Xms和-Xmx的设置为相同大小，因为当heap自动扩容时，会发生内存抖动，影响程序的稳定性）。</p>
<p>-Xmn：n为new，表示新生代大小（-Xss：规定了每个线程虚拟机栈（堆栈）的大小）。</p>
<p>-XX:SurvivorRator=8 表示堆内存中新生代、老年代和永久代的比为8:1:1。</p>
<p>-XX:PretenureSizeThreshold=3145728表示当创建（new）的对象大于3M的时候直接进入。</p>
<p>-XX:MaxTenuringThreshold=15表示当对象的存活的年龄（minor gc一次加1）大于多少时，进入老年代。</p>
<p>-XX:-DisableExplicirGC表示是否（+表示是，-表示否）打开GC日志。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/23/2034/" rel="prev" title="2034">
      <i class="fa fa-chevron-left"></i> 2034
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">重载和重写的区别（了解）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E5%92%8CStringBuffer-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FString-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F%EF%BC%88%E5%BF%85%E4%BC%9A%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">String和StringBuffer,StringBuilder 的区别是什么？String 为什么是不可变的？（必会）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1-%E4%BA%86%E8%A7%A3"><span class="nav-number">3.</span> <span class="nav-text">自动装箱与拆箱*****(了解)*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E-equals-%E5%BF%85%E4%BC%9A"><span class="nav-number">4.</span> <span class="nav-text">&#x3D;&#x3D; 与 equals(必会)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8Efinal%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93-%E5%BF%85%E4%BC%9A"><span class="nav-number">5.</span> <span class="nav-text">关于final关键字的一些总结(必会)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-%E4%BA%86%E8%A7%A3"><span class="nav-number">6.</span> <span class="nav-text">Java 中的异常处理(了解)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#error-%E5%92%8C-exception-%E7%9A%84%E5%8C%BA%E5%88%AB-%E4%BA%86%E8%A7%A3"><span class="nav-number">7.</span> <span class="nav-text">error 和 exception 的区别?(了解)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88-%E5%BF%85%E4%BC%9A"><span class="nav-number">8.</span> <span class="nav-text">接口和抽象类的区别是什么(必会)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F-%E5%BF%85%E4%BC%9A"><span class="nav-number">9.</span> <span class="nav-text">什么是单例模式？有几种？(必会)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%9F-%E5%BF%85%E4%BC%9A"><span class="nav-number">10.</span> <span class="nav-text">手写冒泡排序？(必会)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO%E3%80%81NIO%E3%80%81AIO-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-%E4%BA%86%E8%A7%A3"><span class="nav-number">11.</span> <span class="nav-text">BIO、NIO、AIO 有什么区别？(了解)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-%E4%BA%86%E8%A7%A3"><span class="nav-number">12.</span> <span class="nav-text">常见的数据结构有哪些？(了解)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E6%9C%89%E4%BB%80%E4%B9%88-%E5%BF%85%E4%BC%9A"><span class="nav-number">13.</span> <span class="nav-text">Java集合体系有什么?(必会)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List-%E7%9A%84%E4%B8%89%E4%B8%AA%E5%AD%90%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9-%E5%BF%85%E4%BC%9A"><span class="nav-number">14.</span> <span class="nav-text">List 的三个子类的特点(必会)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List-%E5%92%8C-Map%E3%80%81Set-%E7%9A%84%E5%8C%BA%E5%88%AB-%E5%BF%85%E4%BC%9A"><span class="nav-number">15.</span> <span class="nav-text">List 和 Map、Set 的区别(必会)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E5%BF%85%E4%BC%9A"><span class="nav-number">16.</span> <span class="nav-text">1.16 HashMap底层实现原理(必会)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-17%E8%B0%88%E4%B8%80%E4%B8%8B-hashMap-%E4%B8%AD%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%AE%B9%EF%BC%8C%E6%89%A9%E5%AE%B9-resize-%E5%8F%88%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F-%E9%AB%98%E8%96%AA%E5%B8%B8%E9%97%AE"><span class="nav-number">17.</span> <span class="nav-text">1.17谈一下 hashMap 中什么时候需要进行扩容，扩容 resize()又是如何实现的？(高薪常问)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap%E7%89%B9%E7%82%B9-%E9%AB%98%E8%96%AA%E5%B8%B8%E9%97%AE"><span class="nav-number">18.</span> <span class="nav-text">ConcurrentHashMap特点(高薪常问)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashTable-%E4%BA%86%E8%A7%A3"><span class="nav-number">19.</span> <span class="nav-text">HashTable(了解)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E5%92%8C-HashTable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E5%BF%85%E4%BC%9A"><span class="nav-number">20.</span> <span class="nav-text">HashMap 和 HashTable 有什么区别?(必会)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%EF%BC%8CHashTable%EF%BC%8CConcurrentHashMap%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%8F%8A%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94-%E5%BF%85%E4%BC%9A"><span class="nav-number">21.</span> <span class="nav-text">HashMap，HashTable，ConcurrentHashMap之间的区别，及性能对比(必会)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB-%E5%BF%85%E4%BC%9A"><span class="nav-number">22.</span> <span class="nav-text">什么是线程?线程和进程的区别?(必会)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F-%E5%BF%85%E4%BC%9A"><span class="nav-number">23.</span> <span class="nav-text">创建线程有几种方式(必会)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88-%E5%BF%85%E4%BC%9A"><span class="nav-number">24.</span> <span class="nav-text">线程的基本方法有什么?(必会)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-java-%E4%B8%AD-wait-%E5%92%8C-sleep-%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9F-%E5%BF%85%E4%BC%9A"><span class="nav-number">25.</span> <span class="nav-text">在 java 中 wait 和 sleep 方法的不同？(必会)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86-%E9%AB%98%E8%96%AA%E5%B8%B8%E9%97%AE"><span class="nav-number">26.</span> <span class="nav-text">线程池原理(高薪常问)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%9A%84%E9%A1%BA%E5%BA%8F-%E9%AB%98%E8%96%AA%E5%B8%B8%E9%97%AE"><span class="nav-number">27.</span> <span class="nav-text">线程执行的顺序(高薪常问)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-%E9%AB%98%E8%96%AA%E5%B8%B8%E9%97%AE"><span class="nav-number">28.</span> <span class="nav-text">线程池的核心参数有哪些？(高薪常问)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F-%E9%AB%98%E8%96%AA%E5%B8%B8%E9%97%AE"><span class="nav-number">29.</span> <span class="nav-text">死锁产生的条件以及如何避免？(高薪常问)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FJVM%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84-%E9%AB%98%E8%96%AA%E5%B8%B8%E9%97%AE"><span class="nav-number">30.</span> <span class="nav-text">JVM是什么？JVM的基本结构 (高薪常问)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-%E9%AB%98%E8%96%AA%E5%B8%B8%E9%97%AE"><span class="nav-number">31.</span> <span class="nav-text">JVM内存结构(高薪常问)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E7%A7%8D%E7%B1%BB-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-%E9%AB%98%E8%96%AA%E5%B8%B8%E9%97%AE"><span class="nav-number">32.</span> <span class="nav-text">类的加载，类加载器的种类,类加载机制(高薪常问)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFGC-%E9%AB%98%E8%96%AA%E5%B8%B8%E9%97%AE"><span class="nav-number">33.</span> <span class="nav-text">什么是GC(高薪常问)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E8%B0%83%E4%BC%98%E7%9A%84%E5%B7%A5%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-%E9%AB%98%E8%96%AA%E5%B8%B8%E9%97%AE"><span class="nav-number">34.</span> <span class="nav-text">JVM调优的工具有哪些？(高薪常问)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84-JVM-%E8%B0%83%E4%BC%98%E7%9A%84%E5%8F%82%E6%95%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-%E9%AB%98%E8%96%AA%E5%B8%B8%E9%97%AE"><span class="nav-number">35.</span> <span class="nav-text">常用的 JVM 调优的参数都有哪些？(高薪常问)</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="毋  豆"
      src="/images/touxiang.gif">
  <p class="site-author-name" itemprop="name">毋  豆</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wudou" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wudou" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:760237638@qq.com" title="Mail → mailto:760237638@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">毋  豆</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
